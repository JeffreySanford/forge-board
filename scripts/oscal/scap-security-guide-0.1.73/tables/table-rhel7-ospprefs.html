<!DOCTYPE html>
<html>
<head lang="en">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Rules with OSPP Reference in Guide to the Secure Configuration of Red Hat Enterprise Linux 7</title>
</head>
<body>
	<br><br><div style="text-align: center; font-size: x-large; font-weight:bold">Rules with OSPP Reference in Guide to the Secure Configuration of Red Hat Enterprise Linux 7</div>
<br><br><style type="text/css">
		table
		{
			border-collapse:collapse;
		}
		table, th, td
		{
			border: 2px solid #dcdcdc;
			border-left: none;
			border-right: none;
			vertical-align: top;
			padding: 2px;
			font-family: verdana,arial,sans-serif;
			font-size:11px;
		}
		pre { 
			white-space: pre-wrap;
			white-space: -moz-pre-wrap !important;
			word-wrap:break-word; 
		}
		table tr:nth-child(2n+2) { background-color: #f4f4f4; }
		thead
		{
			display: table-header-group;
			font-weight: bold;
			background-color: #dedede;
		}
	</style>

<table>
  <thead>
    <th>Mapping</th>
    <th>Rule Title</th>
    <th>Description</th>
    <th>Rationale</th>
  </thead>
  <tbody>
  <tr>
      <td>AGD_PRE.1<br/>AGD_OPE.1</td>
      <td>Install openscap-scanner Package</td>
      <td xml:lang="en-US">
        The <code>openscap-scanner</code> package can be installed with the following command:
<pre>
$ sudo yum install openscap-scanner</pre>
      </td>
      <td xml:lang="en-US">
        <tt>openscap-scanner</tt> contains the <tt>oscap</tt> command line tool. This tool is a
configuration and vulnerability scanner, capable of performing compliance checking using
SCAP content.
      </td>
    </tr>
    <tr>
      <td>AGD_PRE.1<br/>AGD_OPE.1</td>
      <td>Install scap-security-guide Package</td>
      <td xml:lang="en-US">
        The <code>scap-security-guide</code> package can be installed with the following command:
<pre>
$ sudo yum install scap-security-guide</pre>
      </td>
      <td xml:lang="en-US">
        The <tt>scap-security-guide</tt> package provides a guide for configuration of the system
from the final system's security point of view. The guidance is specified in the Security
Content Automation Protocol (SCAP) format and constitutes a catalog of practical hardening
advice, linked to government requirements where applicable. The SCAP Security Guide project
bridges the gap between generalized policy requirements and specific implementation guidelines.
A system administrator can use the <tt>oscap</tt> CLI tool from the <tt>openscap-scanner</tt>
package, or the SCAP Workbench GUI tool from the <tt>scap-workbench</tt> package, to verify
that the system conforms to provided guidelines. Refer to the scap-security-guide(8) manual
page for futher information.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1</td>
      <td>Configure basic parameters of Audit system</td>
      <td xml:lang="en-US">
        Perform basic configuration of Audit system.
Make sure that any previously defined rules are cleared, the auditing system is configured to handle sudden bursts of events, and in cases of failure, messages are configured to be directed to system log.

The following rules configure audit as described above:
<pre>## First rule - delete all
-D

## Increase the buffers to survive stress events.
## Make this bigger for busy systems
-b 8192

## This determine how long to wait in burst of events
--backlog_wait_time 60000

## Set failure mode to syslog
-f 1    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>
      </td>
      <td xml:lang="en-US">
        Without basic configurations, audit may not perform as expected. It may not be able to correctly handle events under stressful conditions, or log events in case of failure.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1</td>
      <td>Enable Auditing to Start Prior to the Audit Daemon in zIPL</td>
      <td xml:lang="en-US">
        To ensure all processes can be audited, even those which start prior to the audit daemon,
check that all boot entries in <tt>/boot/loader/entries/*.conf</tt> have <tt>audit=1</tt>
included in its options.<br />

To ensure that new kernels and boot entries continue to enable audit,
add <tt>audit=1</tt> to <tt>/etc/kernel/cmdline</tt>.
      </td>
      <td xml:lang="en-US">
        Each process on the system carries an "auditable" flag which indicates whether
its activities can be audited. Although <tt>auditd</tt> takes care of enabling
this for all processes which launch after it does, adding the kernel argument
ensures it is set for every process during boot.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1</td>
      <td>Enable Auditing for Processes Which Start Prior to the Audit Daemon</td>
      <td xml:lang="en-US">
        To ensure all processes can be audited, even those which start
prior to the audit daemon, add the argument <tt>audit=1</tt> to the default
GRUB 2 command line for the Linux operating system.
To ensure that <tt>audit=1</tt> is added as a kernel command line
argument to newly installed kernels, add <tt>audit=1</tt> to the
default Grub2 command line for Linux operating systems. Modify the line within
<tt>/etc/default/grub</tt> as shown below:
<pre>GRUB_CMDLINE_LINUX="... audit=1 ..."</pre>
Run the following command to update command line for already installed kernels:<pre># grubby --update-kernel=ALL --args="audit=1"</pre>
      </td>
      <td xml:lang="en-US">
        Each process on the system carries an "auditable" flag which indicates whether
its activities can be audited. Although <tt>auditd</tt> takes care of enabling
this for all processes which launch after it does, adding the kernel argument
ensures it is set for every process during boot.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1</td>
      <td>Disable SSH Root Login</td>
      <td xml:lang="en-US">
        The root user should never be allowed to login to a
system directly over a network.
To disable root login via SSH, add or correct the following line in


<tt>/etc/ssh/sshd_config</tt>:

<pre>PermitRootLogin no</pre>
      </td>
      <td xml:lang="en-US">
        Even though the communications channel may be encrypted, an additional layer of
security is gained by extending the policy of not logging directly on as root.
In addition, logging in with a user-specific account provides individual
accountability of actions performed on the system and also helps to minimize
direct attack attempts on root's password.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1</td>
      <td>Include Local Events in Audit Logs</td>
      <td xml:lang="en-US">
        To configure Audit daemon to include local events in Audit logs, set
<tt>local_events</tt> to <tt>yes</tt> in <tt>/etc/audit/auditd.conf</tt>.
This is the default setting.
      </td>
      <td xml:lang="en-US">
        If option <tt>local_events</tt> isn't set to <tt>yes</tt> only events from
network will be aggregated.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1</td>
      <td>Set number of records to cause an explicit flush to audit logs</td>
      <td xml:lang="en-US">
        To configure Audit daemon to issue an explicit flush to disk command
after writing <abbr title="$var_auditd_freq"><tt>50</tt></abbr> records, set <tt>freq</tt> to <tt><abbr title="$var_auditd_freq"><tt>50</tt></abbr></tt>
in <tt>/etc/audit/auditd.conf</tt>.
      </td>
      <td xml:lang="en-US">
        If option <tt>freq</tt> isn't set to <tt><sub idref="var_auditd_freq" /></tt>, the flush to disk
may happen after higher number of records, increasing the danger
of audit loss.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1</td>
      <td>Ensure the audit Subsystem is Installed</td>
      <td xml:lang="en-US">
        The audit package should be installed.
      </td>
      <td xml:lang="en-US">
        The auditd service is an access monitoring and accounting daemon, watching system calls to audit any access, in comparison with potential local access control policy such as SELinux policy.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1</td>
      <td>Enable auditd Service</td>
      <td xml:lang="en-US">
        The <tt>auditd</tt> service is an essential userspace component of
the Linux Auditing System, as it is responsible for writing audit records to
disk.

The <code>auditd</code> service can be enabled with the following command:
<pre>$ sudo systemctl enable auditd.service</pre>
      </td>
      <td xml:lang="en-US">
        Without establishing what type of events occurred, it would be difficult
to establish, correlate, and investigate the events leading up to an outage or attack.
Ensuring the <tt>auditd</tt> service is active ensures audit records
generated by the kernel are appropriately recorded.
<br /><br />
Additionally, a properly configured audit subsystem ensures that actions of
individual system users can be uniquely traced to those users so they
can be held accountable for their actions.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1</td>
      <td>Ensure the audit-libs package as a part of audit Subsystem is Installed</td>
      <td xml:lang="en-US">
        The audit-libs package should be installed.
      </td>
      <td xml:lang="en-US">
        The auditd service is an access monitoring and accounting daemon, watching system calls to audit any access, in comparison with potential local access control policy such as SELinux policy.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Ensure auditd Collects Information on Kernel Module Loading and Unloading - finit_module</td>
      <td xml:lang="en-US">
        If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt> program
to read audit rules during daemon startup (the default), add the following lines to a file
with suffix <tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt> to capture kernel module
loading and unloading events, setting ARCH to either b32 or b64 as appropriate for your system:

<pre>-a always,exit -F arch=<i>ARCH</i> -S finit_module -F auid>=1000 -F auid!=unset -F key=modules</pre>
    If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt> utility to read audit
rules during daemon startup, add the following lines to <tt>/etc/audit/audit.rules</tt> file
in order to capture kernel module loading and unloading events, setting ARCH to either b32 or
b64 as appropriate for your system:

<pre>-a always,exit -F arch=<i>ARCH</i> -S finit_module -F auid>=1000 -F auid!=unset -F key=modules</pre>
      </td>
      <td xml:lang="en-US">
        The addition/removal of kernel modules can be used to alter the behavior of
the kernel and potentially introduce malicious code into kernel space. It is important
to have an audit trail of modules that have been introduced into the kernel.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Ensure auditd Collects Information on the Use of Privileged Commands - ssh-keysign</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect the execution of
privileged commands for all users and root. If the <tt>auditd</tt> daemon is
configured to use the <tt>augenrules</tt> program to read audit rules during
daemon startup (the default), add a line of the following form to a file with
suffix <tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/libexec/openssh/ssh-keysign -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the following
form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/libexec/openssh/ssh-keysign -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>
      </td>
      <td xml:lang="en-US">
        Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Configure auditing of unsuccessful file creations (AArch64)</td>
      <td xml:lang="en-US">
        Ensure that unsuccessful attempts to create a file are audited.

The following rules configure audit as described above:
<pre>## Unsuccessful file creation (open with O_CREAT)
-a always,exit -F arch=b32 -S openat,open_by_handle_at -F a2&amp;0100 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;0100 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b32 -S open -F a1&amp;0100 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b32 -S creat -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b32 -S openat,open_by_handle_at -F a2&amp;0100 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;0100 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b32 -S open -F a1&amp;0100 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b32 -S creat -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-create    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are alligned with your needs.
      </td>
      <td xml:lang="en-US">
        Unsuccessful file creations might be a sign of a malicious action being performed on the system. Keeping log of such events helps in monitoring and investigation of such actions.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Events that Modify User/Group Information via openat syscall - /etc/group</td>
      <td xml:lang="en-US">
        The audit system should collect write events to /etc/group file for all users and root.
If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S openat -F a2&amp;03 -F path=/etc/group -F auid>=1000 -F auid!=unset -F key=modify</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S openat -F a2&amp;03 -F path=/etc/group -F auid>=1000 -F auid!=unset -F key=modify</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S openat -F a2&amp;03 -F path=/etc/group -F auid>=1000 -F auid!=unset -F key=modify</pre>
      </td>
      <td xml:lang="en-US">
        Creation of groups through direct edition of /etc/group could be an indicator of malicious activity on a system.
Auditing these events could serve as evidence of potential system compromise.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Configure auditing of successful file deletions (ppc64le)</td>
      <td xml:lang="en-US">
        Ensure that successful attempts to delete a file are audited.

The following rules configure audit as described above:
<pre>## Successful file delete
-a always,exit -F arch=b64 -S unlink,unlinkat,rename,renameat -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-delete    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are alligned with your needs.
      </td>
      <td xml:lang="en-US">
        Auditing of successful attempts to delete a file may help in monitoring and investigation of activities performed on the system.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Attempts to Alter Logon and Logout Events - faillock</td>
      <td xml:lang="en-US">
        The audit system already collects login information for all users
and root. If the <tt>auditd</tt> daemon is configured to use the
<tt>augenrules</tt> program to read audit rules during daemon startup (the
default), add the following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt> in order to watch for attempted manual
edits of files involved in storing logon events:
<pre>-w <abbr title="$var_accounts_passwords_pam_faillock_dir"><tt>/var/log/faillock</tt></abbr> -p wa -k logins</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file in order to watch for unattempted manual
edits of files involved in storing logon events:
<pre>-w <abbr title="$var_accounts_passwords_pam_faillock_dir"><tt>/var/log/faillock</tt></abbr> -p wa -k logins</pre>
      </td>
      <td xml:lang="en-US">
        Manual editing of these files may indicate nefarious activity, such
as an attacker attempting to remove evidence of an intrusion.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Events that Modify the System's Discretionary Access Controls - fchown</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect file permission
changes for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following line to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S fchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>

If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S fchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S fchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>

If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S fchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
      </td>
      <td xml:lang="en-US">
        The changing of file permissions could indicate that a user is attempting to
gain access to information that would otherwise be disallowed. Auditing DAC modifications
can facilitate the identification of patterns of abuse among both authorized and
unauthorized users.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Configure auditing of unsuccessful file creations (ppc64le)</td>
      <td xml:lang="en-US">
        Ensure that unsuccessful attempts to create a file are audited.

The following rules configure audit as described above:
<pre>## Unsuccessful file creation (open with O_CREAT)
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;0100 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b64 -S open -F a1&amp;0100 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b64 -S creat -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;0100 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b64 -S open -F a1&amp;0100 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b64 -S creat -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-create    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are alligned with your needs.
      </td>
      <td xml:lang="en-US">
        Unsuccessful file creations might be a sign of a malicious action being performed on the system. Keeping log of such events helps in monitoring and investigation of such actions.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Ensure auditd Collects Information on Kernel Module Loading - init_module</td>
      <td xml:lang="en-US">
        To capture kernel module loading events, use following line, setting ARCH to
either b32 for 32-bit system, or having two lines for both b32 and b64 in case your system is 64-bit:

<pre>-a always,exit -F arch=<i>ARCH</i> -S init_module -F auid>=1000 -F auid!=unset -F key=modules</pre>


Place to add the line depends on a way <tt>auditd</tt> daemon is configured. If it is configured
to use the <tt>augenrules</tt> program (the default), add the line to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>.

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt> utility,
add the line to file <tt>/etc/audit/audit.rules</tt>.
      </td>
      <td xml:lang="en-US">
        The addition of kernel modules can be used to alter the behavior of
the kernel and potentially introduce malicious code into kernel space. It is important
to have an audit trail of modules that have been introduced into the kernel.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Configure audispd Plugin To Send Logs To Remote Server</td>
      <td xml:lang="en-US">
        Configure the audispd plugin to off-load audit records onto a different
system or media from the system being audited.

Set the <tt>remote_server</tt> option in <pre>/etc/audisp/audisp-remote.conf</pre>
with an IP address or hostname of the system that the audispd plugin should
send audit records to. For example
<pre>remote_server = <i><abbr title="$var_audispd_remote_server"><tt>logcollector</tt></abbr></i></pre>
      </td>
      <td xml:lang="en-US">
        Information stored in one location is vulnerable to accidental or incidental
deletion or alteration.Off-loading is a common process in information systems
with limited audit storage capacity.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Configure audit according to OSPP requirements</td>
      <td xml:lang="en-US">
        Configure audit to meet requirements for Operating System Protection Profile (OSPP) v4.2.1.

Audit defines groups of rules in <tt>/usr/share/doc/audit/rules</tt> to satisfy specific policies.

To fulfill requirements for compliance with OSPP v4.2.1, the following files are necessary:
<ul>
<li>/usr/share/doc/audit-VERSION/rules/10-base-config.rules</li>
<li>/usr/share/doc/audit-VERSION/rules/11-loginuid.rules</li>
<li>/usr/share/doc/audit-VERSION/rules/30-ospp-v42.rules</li>
<li>/usr/share/doc/audit-VERSION/rules/43-module-load.rules</li>
</ul>

Copy the files from <tt>/usr/share/doc/audit/rules</tt> to <tt>/etc/audit/rules.d</tt>:
<pre>
cp /usr/share/doc/audit*/rules/{10-base-config,11-loginuid,30-ospp-v42,43-module-load}.rules /etc/audit/rules.d/
</pre>
      </td>
      <td xml:lang="en-US">
        The audit rules defined in <tt>/usr/share/doc/audit/rules</tt> are the recommended way to meet compliance with OSPP v4.2.1.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Ensure Logs Sent To Remote Host</td>
      <td xml:lang="en-US">
        To configure rsyslog to send logs to a remote log server,
open <tt>/etc/rsyslog.conf</tt> and read and understand the last section of the file,
which describes the multiple directives necessary to activate remote
logging.
Along with these other directives, the system can be configured
to forward its logs to a particular log server by
adding or correcting one of the following lines,
substituting <tt><i><abbr title="$rsyslog_remote_loghost_address"><tt>logcollector</tt></abbr></i></tt> appropriately.
The choice of protocol depends on the environment of the system;
although TCP and RELP provide more reliable message delivery,
they may not be supported in all environments.
<br />
To use UDP for log message delivery:
<pre>*.* @<i><abbr title="$rsyslog_remote_loghost_address"><tt>logcollector</tt></abbr></i></pre>
<br />
To use TCP for log message delivery:
<pre>*.* @@<i><abbr title="$rsyslog_remote_loghost_address"><tt>logcollector</tt></abbr></i></pre>
<br />
To use RELP for log message delivery:
<pre>*.* :omrelp:<i><abbr title="$rsyslog_remote_loghost_address"><tt>logcollector</tt></abbr></i></pre>
<br />
There must be a resolvable DNS CNAME or Alias record set to "<abbr title="$rsyslog_remote_loghost_address"><tt>logcollector</tt></abbr>" for logs to be sent correctly to the centralized logging utility.
      </td>
      <td xml:lang="en-US">
        A log server (loghost) receives syslog messages from one or more
systems. This data can be used as an additional log source in the event a
system is compromised and its local logs are suspect. Forwarding log messages
to a remote loghost also provides system administrators with a centralized
place to view the status of multiple hosts within the enterprise.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Configure auditing of unsuccessful permission changes (ppc64le)</td>
      <td xml:lang="en-US">
        Ensure that unsuccessful attempts to change file or directory permissions are audited.

The following rules configure audit as described above:
<pre>## Unsuccessful permission change
-a always,exit -F arch=b64 -S chmod,fchmod,fchmodat,setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-perm-change
-a always,exit -F arch=b64 -S chmod,fchmod,fchmodat,setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-perm-change    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are alligned with your needs.
      </td>
      <td xml:lang="en-US">
        Unsuccessful attempts to change permissions of files or directories might be signs of malicious activity. Having such events audited helps in monitoring and investigation of such activities.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Ensure auditd Collects File Deletion Events by User - unlinkat</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect file deletion events
for all users and root. If the <tt>auditd</tt> daemon is configured to use the
<tt>augenrules</tt> program to read audit rules during daemon startup (the
default), add the following line to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>, setting ARCH to either b32 or b64 as
appropriate for your system:
<pre>-a always,exit -F arch=ARCH -S unlinkat -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file, setting ARCH to either b32 or b64 as
appropriate for your system:
<pre>-a always,exit -F arch=ARCH -S unlinkat -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>
      </td>
      <td xml:lang="en-US">
        Auditing file deletions will create an audit trail for files that are removed
from the system. The audit trail could aid in system troubleshooting, as well as, detecting
malicious processes that attempt to delete log files to conceal their presence.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Ensure auditd Collects Information on the Use of Privileged Commands - newgidmap</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect the execution of
privileged commands for all users and root. If the <tt>auditd</tt> daemon is
configured to use the <tt>augenrules</tt> program to read audit rules during
daemon startup (the default), add a line of the following form to a file with
suffix <tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/bin/newgidmap -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the following
form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/bin/newgidmap -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>
      </td>
      <td xml:lang="en-US">
        Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Configure auditing of loading and unloading of kernel modules (ppc64le)</td>
      <td xml:lang="en-US">
        Ensure that loading and unloading of kernel modules is audited.

The following rules configure audit as described above:
<pre>## These rules watch for kernel module insertion. By monitoring
## the syscall, we do not need any watches on programs.
-a always,exit -F arch=b64 -S init_module,finit_module -F key=module-load
-a always,exit -F arch=b64 -S delete_module -F key=module-unload    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>
      </td>
      <td xml:lang="en-US">
        Loading of a malicious kernel module introduces a risk to the system, as the module has access to sensitive data and perform actions at the operating system kernel level. Having such events audited helps in monitoring and investigating of malicious activities.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Ensure auditd Collects Information on the Use of Privileged Commands - usernetctl</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect the execution of
privileged commands for all users and root. If the <tt>auditd</tt> daemon is
configured to use the <tt>augenrules</tt> program to read audit rules during
daemon startup (the default), add a line of the following form to a file with
suffix <tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/sbin/usernetctl -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the following
form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/sbin/usernetctl -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>
      </td>
      <td xml:lang="en-US">
        Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Configure auditing of successful file accesses (AArch64)</td>
      <td xml:lang="en-US">
        Ensure that successful attempts to access a file are audited.

The following rules configure audit as described above:
<pre>## Successful file access (any other opens) This has to go last.
## These next two are likely to result in a whole lot of events
-a always,exit -F arch=b32 -S open,openat,openat2,open_by_handle_at -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-access
-a always,exit -F arch=b64 -S openat,openat2,open_by_handle_at -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-access    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are alligned with your needs.
      </td>
      <td xml:lang="en-US">
        Auditing of successful attempts to access a file helps in investigation of activities performed on the system.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Configure auditing of successful ownership changes (ppc64le)</td>
      <td xml:lang="en-US">
        Ensure that successful attempts to change an ownership of files or directories are audited.

The following rules configure audit as described above:
<pre>## Successful ownership change
-a always,exit -F arch=b64 -S lchown,fchown,chown,fchownat -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-owner-change    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are alligned with your needs.
      </td>
      <td xml:lang="en-US">
        Auditing of successful ownership changes of files or directories helps in monitoring or investingating of activities performed on the system.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Configure auditing of unsuccessful ownership changes</td>
      <td xml:lang="en-US">
        Ensure that unsuccessful attempts to change an ownership of files or directories are audited.

The following rules configure audit as described above:
<pre>## Unsuccessful ownership change
-a always,exit -F arch=b32 -S lchown,fchown,chown,fchownat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-owner-change
-a always,exit -F arch=b64 -S lchown,fchown,chown,fchownat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-owner-change
-a always,exit -F arch=b32 -S lchown,fchown,chown,fchownat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-owner-change
-a always,exit -F arch=b64 -S lchown,fchown,chown,fchownat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-owner-change    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are alligned with your needs.
      </td>
      <td xml:lang="en-US">
        Unsuccessful attempts to change an ownership of files or directories might be signs of a malicious activity. Having such events audited helps in monitoring and investigation of such activities.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Events that Modify User/Group Information via open syscall - /etc/shadow</td>
      <td xml:lang="en-US">
        The audit system should collect write events to /etc/shadow file for all users and root.
If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S open -F a1&amp;03 -F path=/etc/shadow -F auid>=1000 -F auid!=unset -F key=user-modify</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S open -F a1&amp;03 -F path=/etc/shadow -F auid>=1000 -F auid!=unset -F key=user-modify</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S open -F a1&amp;03 -F path=/etc/shadow -F auid>=1000 -F auid!=unset -F key=user-modify</pre>
      </td>
      <td xml:lang="en-US">
        Creation of users through direct edition of /etc/shadow could be an indicator of malicious activity on a system.
Auditing these events could serve as evidence of potential system compromise.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Events that Modify User/Group Information - /etc/gshadow</td>
      <td xml:lang="en-US">
        If the <tt>auditd</tt> daemon is configured to use the
<tt>augenrules</tt> program to read audit rules during daemon startup (the
default), add the following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>, in order to capture events that modify
account changes:
<br /><br />
<pre>-w /etc/gshadow -p wa -k audit_rules_usergroup_modification</pre>
<br /><br />
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file, in order to capture events that modify
account changes:
<br /><br />
<pre>-w /etc/gshadow -p wa -k audit_rules_usergroup_modification</pre>
      </td>
      <td xml:lang="en-US">
        In addition to auditing new user and group accounts, these watches
will alert the system administrator(s) to any modifications. Any unexpected
users, groups, or modifications should be investigated for legitimacy.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Configure auditing of successful permission changes</td>
      <td xml:lang="en-US">
        Ensure that successful attempts to modify permissions of files or directories are audited.

The following rules configure audit as described above:
<pre>## Successful permission change
-a always,exit -F arch=b32 -S chmod,fchmod,fchmodat,setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change
-a always,exit -F arch=b64 -S chmod,fchmod,fchmodat,setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are alligned with your needs.
      </td>
      <td xml:lang="en-US">
        Auditing successful file or directory permission changes helps in monitoring and investigating of activities performed on the system.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Events that Modify User/Group Information via open_by_handle_at syscall - /etc/passwd</td>
      <td xml:lang="en-US">
        The audit system should collect write events to /etc/passwd file for all users and root.
If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S open_by_handle_at -F a2&amp;03 -F path=/etc/passwd -F auid>=1000 -F auid!=unset -F key=modify</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S open_by_handle_at -F a2&amp;03 -F path=/etc/passwd -F auid>=1000 -F auid!=unset -F key=modify</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S open_by_handle_at -F a2&amp;03 -F path=/etc/passwd -F auid>=1000 -F auid!=unset -F key=modify</pre>
      </td>
      <td xml:lang="en-US">
        Creation of users through direct edition of /etc/passwd could be an indicator of malicious activity on a system.
Auditing these events could serve as evidence of potential system compromise.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Configure auditing of successful file creations (ppc64le)</td>
      <td xml:lang="en-US">
        Ensure that successful attempts to create a file are audited.

The following rules configure audit as described above:
<pre>## Successful file creation (open with O_CREAT)
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;0100 -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-create
-a always,exit -F arch=b64 -S open -F a1&amp;0100 -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-create
-a always,exit -F arch=b64 -S creat -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-create    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are alligned with your needs.
      </td>
      <td xml:lang="en-US">
        Auditing of successful attempts to create a file helps in investigation of actions which happened on the system.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Perform general configuration of Audit for OSPP</td>
      <td xml:lang="en-US">
        Configure some basic <tt>Audit</tt> parameters specific for OSPP profile.
In particular, configure <tt>Audit</tt> to watch for direct modification of files storing system user and group information, and usage of applications with special rights which can change system configuration.
Further audited events include access to audit log it self, attempts to Alter Process and Session Initiation Information, and attempts to modify MAC controls.

The following rules configure audit as described above:
<pre>## The purpose of these rules is to meet the requirements for Operating
## System Protection Profile (OSPP)v4.2. These rules depends on having
## the following rule files copied to /etc/audit/rules.d:
##
## 10-base-config.rules, 11-loginuid.rules,
## 30-ospp-v42-1-create-failed.rules, 30-ospp-v42-1-create-success.rules,
## 30-ospp-v42-2-modify-failed.rules, 30-ospp-v42-2-modify-success.rules,
## 30-ospp-v42-3-access-failed.rules, 30-ospp-v42-3-access-success.rules,
## 30-ospp-v42-4-delete-failed.rules, 30-ospp-v42-4-delete-success.rules,
## 30-ospp-v42-5-perm-change-failed.rules,
## 30-ospp-v42-5-perm-change-success.rules,
## 30-ospp-v42-6-owner-change-failed.rules,
## 30-ospp-v42-6-owner-change-success.rules
##
## original copies may be found in /usr/share/audit/sample-rules/


## User add delete modify. This is covered by pam. However, someone could
## open a file and directly create or modify a user, so we'll watch passwd and
## shadow for writes
-a always,exit -F arch=b32 -S openat,open_by_handle_at -F a2&amp;03 -F path=/etc/passwd -F auid&gt;=1000 -F auid!=unset -F key=user-modify
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;03 -F path=/etc/passwd -F auid&gt;=1000 -F auid!=unset -F key=user-modify
-a always,exit -F arch=b32 -S open -F a1&amp;03 -F path=/etc/passwd -F auid&gt;=1000 -F auid!=unset -F key=user-modify
-a always,exit -F arch=b64 -S open -F a1&amp;03 -F path=/etc/passwd -F auid&gt;=1000 -F auid!=unset -F key=user-modify
-a always,exit -F arch=b32 -S openat,open_by_handle_at -F a2&amp;03 -F path=/etc/shadow -F auid&gt;=1000 -F auid!=unset -F key=user-modify
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;03 -F path=/etc/shadow -F auid&gt;=1000 -F auid!=unset -F key=user-modify
-a always,exit -F arch=b32 -S open -F a1&amp;03 -F path=/etc/shadow -F auid&gt;=1000 -F auid!=unset -F key=user-modify
-a always,exit -F arch=b64 -S open -F a1&amp;03 -F path=/etc/shadow -F auid&gt;=1000 -F auid!=unset -F key=user-modify

## User enable and disable. This is entirely handled by pam.

## Group add delete modify. This is covered by pam. However, someone could
## open a file and directly create or modify a user, so we'll watch group and
## gshadow for writes
-a always,exit -F path=/etc/passwd -F perm=wa -F auid&gt;=1000 -F auid!=unset -F key=user-modify
-a always,exit -F path=/etc/shadow -F perm=wa -F auid&gt;=1000 -F auid!=unset -F key=user-modify
-a always,exit -F path=/etc/group -F perm=wa -F auid&gt;=1000 -F auid!=unset -F key=group-modify
-a always,exit -F path=/etc/gshadow -F perm=wa -F auid&gt;=1000 -F auid!=unset -F key=group-modify


## Use of special rights for config changes. This would be use of setuid
## programs that relate to user accts. This is not all setuid apps because
## requirements are only for ones that affect system configuration.
-a always,exit -F path=/usr/sbin/unix_chkpwd -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F path=/usr/sbin/usernetctl -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F path=/usr/sbin/userhelper -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F path=/usr/sbin/seunshare -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F path=/usr/bin/mount -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F path=/usr/bin/newgrp -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F path=/usr/bin/newuidmap -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F path=/usr/bin/gpasswd -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F path=/usr/bin/newgidmap -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F path=/usr/bin/umount -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F path=/usr/bin/passwd -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F path=/usr/bin/crontab -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F path=/usr/bin/at -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F path=/usr/sbin/grub2-set-bootflag -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=special-config-changes

## Privilege escalation via su or sudo. This is entirely handled by pam.
## Special case for systemd-run. It is not audit aware, specifically watch it
-a always,exit -F path=/usr/bin/systemd-run -F perm=x -F auid!=unset -F key=maybe-escalation
## Special case for pkexec. It is not audit aware, specifically watch it
-a always,exit -F path=/usr/bin/pkexec -F perm=x -F key=maybe-escalation


## Watch for configuration changes to privilege escalation.
-a always,exit -F path=/etc/sudoers -F perm=wa -F key=special-config-changes
-a always,exit -F dir=/etc/sudoers.d/ -F perm=wa -F key=special-config-changes

## Audit log access
-a always,exit -F dir=/var/log/audit/ -F perm=r -F auid&gt;=1000 -F auid!=unset -F key=access-audit-trail
## Attempts to Alter Process and Session Initiation Information
-a always,exit -F path=/var/run/utmp -F perm=wa -F auid&gt;=1000 -F auid!=unset -F key=session
-a always,exit -F path=/var/log/btmp -F perm=wa -F auid&gt;=1000 -F auid!=unset -F key=session
-a always,exit -F path=/var/log/wtmp -F perm=wa -F auid&gt;=1000 -F auid!=unset -F key=session

## Attempts to modify MAC controls
-a always,exit -F dir=/etc/selinux/ -F perm=wa -F auid&gt;=1000 -F auid!=unset -F key=MAC-policy

## Software updates. This is entirely handled by rpm.

## System start and shutdown. This is entirely handled by systemd

## Kernel Module loading. This is handled in 43-module-load.rules

## Application invocation. The requirements list an optional requirement
## FPT_SRP_EXT.1 Software Restriction Policies. This event is intended to
## state results from that policy. This would be handled entirely by
## that daemon.    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are alligned with your needs.
      </td>
      <td xml:lang="en-US">
        Auditing of events listed in the description provides data for monitoring and investigation of potentially malicious events e.g. tampering with <tt>Audit</tt> logs, malicious access to files storing information about system users and groups etc.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Unsuccessful Delete Attempts to Files - renameat</td>
      <td xml:lang="en-US">
        
The audit system should collect unsuccessful file deletion
attempts for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>.
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file.
<pre>-a always,exit -F arch=b32 -S renameat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete
-a always,exit -F arch=b32 -S renameat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete</pre>
If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S renameat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete
-a always,exit -F arch=b64 -S renameat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete</pre>
      </td>
      <td xml:lang="en-US">
        Unsuccessful attempts to delete files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Configure auditing of successful file creations</td>
      <td xml:lang="en-US">
        Ensure that successful attempts to create a file are audited.

The following rules configure audit as described above:
<pre>## Successful file creation (open with O_CREAT)
-a always,exit -F arch=b32 -S openat,open_by_handle_at -F a2&amp;0100 -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-create
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;0100 -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-create
-a always,exit -F arch=b32 -S open -F a1&amp;0100 -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-create
-a always,exit -F arch=b64 -S open -F a1&amp;0100 -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-create
-a always,exit -F arch=b32 -S creat -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-create
-a always,exit -F arch=b64 -S creat -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-create    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are alligned with your needs.
      </td>
      <td xml:lang="en-US">
        Auditing of successful attempts to create a file helps in investigation of actions which happened on the system.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Events that Modify the System's Discretionary Access Controls - lsetxattr</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect file permission
changes for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following line to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S lsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S lsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S lsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S lsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
      </td>
      <td xml:lang="en-US">
        The changing of file permissions could indicate that a user is attempting to
gain access to information that would otherwise be disallowed. Auditing DAC modifications
can facilitate the identification of patterns of abuse among both authorized and
unauthorized users.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Events that Modify User/Group Information via open_by_handle_at syscall - /etc/shadow</td>
      <td xml:lang="en-US">
        The audit system should collect write events to /etc/shadow file for all users and root.
If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S open_by_handle_at -F a2&amp;03 -F path=/etc/shadow -F auid>=1000 -F auid!=unset -F key=user-modify</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S open_by_handle_at -F a2&amp;03 -F path=/etc/shadow -F auid>=1000 -F auid!=unset -F key=user-modify</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S open_by_handle_at -F a2&amp;03 -F path=/etc/shadow -F auid>=1000 -F auid!=unset -F key=user-modify</pre>
      </td>
      <td xml:lang="en-US">
        Creation of users through direct edition of /etc/shadow could be an indicator of malicious activity on a system.
Auditing these events could serve as evidence of potential system compromise.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Any Attempts to Run semanage</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect any execution attempt
of the <tt>semanage</tt> command for all users and root. If the <tt>auditd</tt>
daemon is configured to use the <tt>augenrules</tt> program to read audit rules
during daemon startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/sbin/semanage -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F path=/usr/sbin/semanage -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>
      </td>
      <td xml:lang="en-US">
        Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Events that Modify the System's Mandatory Access Controls</td>
      <td xml:lang="en-US">
        If the <tt>auditd</tt> daemon is configured to use the
<tt>augenrules</tt> program to read audit rules during daemon startup (the
default), add the following line to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>:
<pre>-w /etc/selinux/ -p wa -k MAC-policy</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-w /etc/selinux/ -p wa -k MAC-policy</pre>
      </td>
      <td xml:lang="en-US">
        The system's mandatory access policy (SELinux) should not be
arbitrarily changed by anything other than administrator action. All changes to
MAC policy should be audited.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Configure auditing of successful ownership changes (AArch64)</td>
      <td xml:lang="en-US">
        Ensure that successful attempts to change an ownership of files or directories are audited.

The following rules configure audit as described above:
<pre>## Successful ownership change
-a always,exit -F arch=b32 -S lchown,fchown,chown,fchownat -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-owner-change
-a always,exit -F arch=b64 -S fchown,fchownat -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-owner-change    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are alligned with your needs.
      </td>
      <td xml:lang="en-US">
        Auditing of successful ownership changes of files or directories helps in monitoring or investingating of activities performed on the system.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Encrypt Audit Records Sent With audispd Plugin</td>
      <td xml:lang="en-US">
        Configure the operating system to encrypt the transfer of off-loaded audit
records onto a different system or media from the system being audited.

Uncomment the <tt>enable_krb5</tt> option in <pre>/etc/audisp/audisp-remote.conf</pre>,
and set it with the following line:
<pre>enable_krb5 = yes</pre>
      </td>
      <td xml:lang="en-US">
        Information stored in one location is vulnerable to accidental or incidental deletion
or alteration. Off-loading is a common process in information systems with limited
audit storage capacity.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Configure auditing of successful file creations (AArch64)</td>
      <td xml:lang="en-US">
        Ensure that successful attempts to create a file are audited.

The following rules configure audit as described above:
<pre>## Successful file creation (open with O_CREAT)
-a always,exit -F arch=b32 -S openat,open_by_handle_at -F a2&amp;0100 -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-create
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;0100 -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-create
-a always,exit -F arch=b32 -S open -F a1&amp;0100 -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-create
-a always,exit -F arch=b32 -S creat -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-create    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are alligned with your needs.
      </td>
      <td xml:lang="en-US">
        Auditing of successful attempts to create a file helps in investigation of actions which happened on the system.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Ensure auditd Collects Information on the Use of Privileged Commands - passwd</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect the execution of
privileged commands for all users and root. If the <tt>auditd</tt> daemon is
configured to use the <tt>augenrules</tt> program to read audit rules during
daemon startup (the default), add a line of the following form to a file with
suffix <tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/bin/passwd -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the following
form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/bin/passwd -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>
      </td>
      <td xml:lang="en-US">
        Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Unsuccessful Creation Attempts to Files - openat O_CREAT</td>
      <td xml:lang="en-US">
        The audit system should collect unauthorized file accesses for
all users and root. The <tt>openat</tt> syscall can be used to create new files
when O_CREAT flag is specified.

The following auidt rules will asure that unsuccessful attempts to create a
file via <tt>openat</tt> syscall are collected.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
rules below to a file with suffix <tt>.rules</tt> in the directory
<tt>/etc/audit/rules.d</tt>.

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the rules below to
<tt>/etc/audit/audit.rules</tt> file.
<pre>
-a always,exit -F arch=b32 -S openat -F a2&amp;0100 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b32 -S openat -F a2&amp;0100 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S openat -F a2&amp;0100 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b64 -S openat -F a2&amp;0100 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
</pre>
      </td>
      <td xml:lang="en-US">
        Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Ensure auditd Collects File Deletion Events by User</td>
      <td xml:lang="en-US">
        At a minimum the audit system should collect file deletion events
for all users and root. If the <tt>auditd</tt> daemon is configured to use the
<tt>augenrules</tt> program to read audit rules during daemon startup (the
default), add the following line to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>, setting ARCH to either b32 or b64 as
appropriate for your system:
<pre>-a always,exit -F arch=ARCH -S rmdir,unlink,unlinkat,rename,renameat -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file, setting ARCH to either b32 or b64 as
appropriate for your system:
<pre>-a always,exit -F arch=ARCH -S rmdir,unlink,unlinkat,rename -S renameat -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>
      </td>
      <td xml:lang="en-US">
        Auditing file deletions will create an audit trail for files that are removed
from the system. The audit trail could aid in system troubleshooting, as well as, detecting
malicious processes that attempt to delete log files to conceal their presence.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Events that Modify the System's Discretionary Access Controls - fchmodat</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect file permission
changes for all users and root. If the <tt>auditd</tt> daemon is configured to
use the <tt>augenrules</tt> program to read audit rules during daemon startup
(the default), add the following line to a file with suffix <tt>.rules</tt> in
the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S fchmodat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S fchmodat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S fchmodat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S fchmodat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
      </td>
      <td xml:lang="en-US">
        The changing of file permissions could indicate that a user is attempting to
gain access to information that would otherwise be disallowed. Auditing DAC modifications
can facilitate the identification of patterns of abuse among both authorized and
unauthorized users.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Events that Modify User/Group Information via open_by_handle_at syscall - /etc/group</td>
      <td xml:lang="en-US">
        The audit system should collect write events to /etc/group file for all group and root.
If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S open_by_handle_at -F a2&amp;03 -F path=/etc/group -F auid>=1000 -F auid!=unset -F key=modify</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S open_by_handle_at -F a2&amp;03 -F path=/etc/group -F auid>=1000 -F auid!=unset -F key=modify</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S open_by_handle_at -F a2&amp;03 -F path=/etc/group -F auid>=1000 -F auid!=unset -F key=modify</pre>
      </td>
      <td xml:lang="en-US">
        Creation of groups through direct edition of /etc/group could be an indicator of malicious activity on a system.
Auditing these events could serve as evidence of potential system compromise.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Events that Modify User/Group Information via open_by_handle_at syscall - /etc/gshadow</td>
      <td xml:lang="en-US">
        The audit system should collect write events to /etc/gshadow file for all users and root.
If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S open_by_handle_at -F a2&amp;03 -F path=/etc/gshadow -F auid>=1000 -F auid!=unset -F key=user-modify</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S open_by_handle_at -F a2&amp;03 -F path=/etc/gshadow -F auid>=1000 -F auid!=unset -F key=user-modify</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S open_by_handle_at -F a2&amp;03 -F path=/etc/gshadow -F auid>=1000 -F auid!=unset -F key=user-modify</pre>
      </td>
      <td xml:lang="en-US">
        Creation of users through direct edition of /etc/gshadow could be an indicator of malicious activity on a system.
Auditing these events could serve as evidence of potential system compromise.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Configure auditing of unsuccessful permission changes (AArch64)</td>
      <td xml:lang="en-US">
        Ensure that unsuccessful attempts to change file or directory permissions are audited.

The following rules configure audit as described above:
<pre>## Unsuccessful permission change
-a always,exit -F arch=b32 -S chmod,fchmod,fchmodat,setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-perm-change
-a always,exit -F arch=b64 -S fchmod,fchmodat,setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-perm-change
-a always,exit -F arch=b32 -S chmod,fchmod,fchmodat,setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-perm-change
-a always,exit -F arch=b64 -S fchmod,fchmodat,setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-perm-change    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are alligned with your needs.
      </td>
      <td xml:lang="en-US">
        Unsuccessful attempts to change permissions of files or directories might be signs of malicious activity. Having such events audited helps in monitoring and investigation of such activities.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Ensure auditd Collects Information on the Use of Privileged Commands - newgrp</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect the execution of
privileged commands for all users and root. If the <tt>auditd</tt> daemon is
configured to use the <tt>augenrules</tt> program to read audit rules during
daemon startup (the default), add a line of the following form to a file with
suffix <tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/bin/newgrp -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the following
form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/bin/newgrp -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>
      </td>
      <td xml:lang="en-US">
        Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Unsuccessful Access Attempts to Files - truncate</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect unauthorized file
accesses for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S truncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b32 -S truncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S truncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b64 -S truncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S truncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b32 -S truncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S truncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b64 -S truncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>
      </td>
      <td xml:lang="en-US">
        Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Any Attempts to Run chcon</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect any execution attempt
of the <tt>chcon</tt> command for all users and root. If the <tt>auditd</tt>
daemon is configured to use the <tt>augenrules</tt> program to read audit rules
during daemon startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/bin/chcon -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F path=/usr/bin/chcon -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>
      </td>
      <td xml:lang="en-US">
        Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Ensure auditd Collects Information on the Use of Privileged Commands - su</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect the execution of
privileged commands for all users and root. If the <tt>auditd</tt> daemon is
configured to use the <tt>augenrules</tt> program to read audit rules during
daemon startup (the default), add a line of the following form to a file with
suffix <tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/bin/su -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the following
form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/bin/su -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>
      </td>
      <td xml:lang="en-US">
        Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Unsuccessful Modification Attempts to Files - openat O_TRUNC_WRITE</td>
      <td xml:lang="en-US">
        The audit system should collect detailed unauthorized file accesses for
all users and root. The <tt>openat</tt> syscall can be used to modify files
if called for write operation of with O_TRUNC_WRITE flag.

The following auidt rules will asure that unsuccessful attempts to modify a
file via <tt>openat</tt> syscall are collected.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
rules below to a file with suffix <tt>.rules</tt> in the directory
<tt>/etc/audit/rules.d</tt>.

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the rules below to
<tt>/etc/audit/audit.rules</tt> file.
<pre>
-a always,exit -F arch=b32 -S openat -F a2&amp;01003 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b32 -S openat -F a2&amp;01003 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S openat -F a2&amp;01003 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b64 -S openat -F a2&amp;01003 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
</pre>
      </td>
      <td xml:lang="en-US">
        Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Attempts to Alter Logon and Logout Events - tallylog</td>
      <td xml:lang="en-US">
        The audit system already collects login information for all users
and root. If the <tt>auditd</tt> daemon is configured to use the
<tt>augenrules</tt> program to read audit rules during daemon startup (the
default), add the following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt> in order to watch for attempted manual
edits of files involved in storing logon events:
<pre>-w /var/log/tallylog -p wa -k logins</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file in order to watch for unattempted manual
edits of files involved in storing logon events:
<pre>-w /var/log/tallylog -p wa -k logins</pre>
      </td>
      <td xml:lang="en-US">
        Manual editing of these files may indicate nefarious activity, such
as an attacker attempting to remove evidence of an intrusion.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Unsuccessful Access Attempts to Files - ftruncate</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect unauthorized file
accesses for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b32 -S ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b64 -S ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b32 -S ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b64 -S ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>
      </td>
      <td xml:lang="en-US">
        Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Ensure auditd Collects File Deletion Events by User - renameat</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect file deletion events
for all users and root. If the <tt>auditd</tt> daemon is configured to use the
<tt>augenrules</tt> program to read audit rules during daemon startup (the
default), add the following line to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>, setting ARCH to either b32 or b64 as
appropriate for your system:
<pre>-a always,exit -F arch=ARCH -S renameat -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file, setting ARCH to either b32 or b64 as
appropriate for your system:
<pre>-a always,exit -F arch=ARCH -S renameat -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>
      </td>
      <td xml:lang="en-US">
        Auditing file deletions will create an audit trail for files that are removed
from the system. The audit trail could aid in system troubleshooting, as well as, detecting
malicious processes that attempt to delete log files to conceal their presence.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Events that Modify User/Group Information via open syscall - /etc/group</td>
      <td xml:lang="en-US">
        The audit system should collect write events to /etc/group file for all users and root.
If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S open -F a1&amp;03 -F path=/etc/group -F auid>=1000 -F auid!=unset -F key=modify</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S open -F a1&amp;03 -F path=/etc/group -F auid>=1000 -F auid!=unset -F key=modify</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S open -F a1&amp;03 -F path=/etc/group -F auid>=1000 -F auid!=unset -F key=modify</pre>
      </td>
      <td xml:lang="en-US">
        Creation of groups through direct edition of /etc/group could be an indicator of malicious activity on a system.
Auditing these events could serve as evidence of potential system compromise.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Ensure auditd Collects Information on the Use of Privileged Commands - sudo</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect the execution of
privileged commands for all users and root. If the <tt>auditd</tt> daemon is
configured to use the <tt>augenrules</tt> program to read audit rules during
daemon startup (the default), add a line of the following form to a file with
suffix <tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/bin/sudo -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the following
form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/bin/sudo -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>
      </td>
      <td xml:lang="en-US">
        Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Configure auditing of successful permission changes (AArch64)</td>
      <td xml:lang="en-US">
        Ensure that successful attempts to modify permissions of files or directories are audited.

The following rules configure audit as described above:
<pre>## Successful permission change
-a always,exit -F arch=b32 -S chmod,fchmod,fchmodat,setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-perm-change
-a always,exit -F arch=b64 -S fchmod,fchmodat,setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-perm-change    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are alligned with your needs.
      </td>
      <td xml:lang="en-US">
        Auditing successful file or directory permission changes helps in monitoring and investigating of activities performed on the system.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Configure auditing of unsuccessful file creations</td>
      <td xml:lang="en-US">
        Ensure that unsuccessful attempts to create a file are audited.

The following rules configure audit as described above:
<pre>## Unsuccessful file creation (open with O_CREAT)
-a always,exit -F arch=b32 -S openat,open_by_handle_at -F a2&amp;0100 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;0100 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b32 -S open -F a1&amp;0100 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b64 -S open -F a1&amp;0100 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b32 -S creat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b64 -S creat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b32 -S openat,open_by_handle_at -F a2&amp;0100 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;0100 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b32 -S open -F a1&amp;0100 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b64 -S open -F a1&amp;0100 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b32 -S creat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b64 -S creat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-create    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are alligned with your needs.
      </td>
      <td xml:lang="en-US">
        Unsuccessful file creations might be a sign of a malicious action being performed on the system. Keeping log of such events helps in monitoring and investigation of such actions.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Any Attempts to Run setsebool</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect any execution attempt
of the <tt>setsebool</tt> command for all users and root. If the <tt>auditd</tt>
daemon is configured to use the <tt>augenrules</tt> program to read audit rules
during daemon startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/sbin/setsebool -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F path=/usr/sbin/setsebool -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>
      </td>
      <td xml:lang="en-US">
        Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Events that Modify the System's Discretionary Access Controls - removexattr</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect file permission
changes for all users and root.
<br /><br />
If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
following line to a file with suffix <tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S removexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
<br /><br />
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S removexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
<br /><br />
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S removexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
<br /><br />
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S removexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
      </td>
      <td xml:lang="en-US">
        The changing of file permissions could indicate that a user is attempting to
gain access to information that would otherwise be disallowed. Auditing DAC modifications
can facilitate the identification of patterns of abuse among both authorized and
unauthorized users.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Configure auditing of successful file modifications (AArch64)</td>
      <td xml:lang="en-US">
        Ensure that successful attempts to modify a file are audited.

The following rules configure audit as described above:
<pre>## Successful file modifications (open for write or truncate)
-a always,exit -F arch=b32 -S openat,open_by_handle_at -F a2&amp;01003 -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-modification
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;01003 -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-modification
-a always,exit -F arch=b32 -S open -F a1&amp;01003 -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-modification
-a always,exit -F arch=b32 -S truncate,ftruncate -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-modification
-a always,exit -F arch=b64 -S truncate,ftruncate -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-modification    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are alligned with your needs.
      </td>
      <td xml:lang="en-US">
        Auditing of successful attempts to modify a file helps in investigation of actions which happened on the system.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Ensure cron Is Logging To Rsyslog</td>
      <td xml:lang="en-US">
        Cron logging must be implemented to spot intrusions or trace
cron job status. If <tt>cron</tt> is not logging to <tt>rsyslog</tt>, it
can be implemented by adding the following to the <i>RULES</i> section of
<tt>/etc/rsyslog.conf</tt>:
<pre>cron.*                                                  /var/log/cron</pre>
      </td>
      <td xml:lang="en-US">
        Cron logging can be used to trace the successful or unsuccessful execution
of cron jobs. It can also be used to spot intrusions into the use of the cron
facility by unauthorized and malicious users.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Configure auditing of successful file accesses (ppc64le)</td>
      <td xml:lang="en-US">
        Ensure that successful attempts to access a file are audited.

The following rules configure audit as described above:
<pre>## Successful file access (any other opens) This has to go last.
## These next two are likely to result in a whole lot of events
-a always,exit -F arch=b64 -S open,openat,openat2,open_by_handle_at -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-access    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are alligned with your needs.
      </td>
      <td xml:lang="en-US">
        Auditing of successful attempts to access a file helps in investigation of activities performed on the system.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Configure auditing of successful file modifications</td>
      <td xml:lang="en-US">
        Ensure that successful attempts to modify a file are audited.

The following rules configure audit as described above:
<pre>## Successful file modifications (open for write or truncate)
-a always,exit -F arch=b32 -S openat,open_by_handle_at -F a2&amp;01003 -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-modification
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;01003 -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-modification
-a always,exit -F arch=b32 -S open -F a1&amp;01003 -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-modification
-a always,exit -F arch=b64 -S open -F a1&amp;01003 -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-modification
-a always,exit -F arch=b32 -S truncate,ftruncate -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-modification
-a always,exit -F arch=b64 -S truncate,ftruncate -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-modification    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are alligned with your needs.
      </td>
      <td xml:lang="en-US">
        Auditing of successful attempts to modify a file helps in investigation of actions which happened on the system.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Configure auditing of unsuccessful file modifications (AARch64)</td>
      <td xml:lang="en-US">
        Ensure that unsuccessful attempts to modify a file are audited.

The following rules configure audit as described above:
<pre>## Unsuccessful file modifications (open for write or truncate)
-a always,exit -F arch=b32 -S openat,open_by_handle_at -F a2&amp;01003 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;01003 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b32 -S open -F a1&amp;01003 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b32 -S truncate,ftruncate -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b64 -S truncate,ftruncate -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b32 -S openat,open_by_handle_at -F a2&amp;01003 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;01003 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b32 -S open -F a1&amp;01003 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b32 -S truncate,ftruncate -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b64 -S truncate,ftruncate -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-modification    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are alligned with your needs.
      </td>
      <td xml:lang="en-US">
        Unsuccessful file modifications might be a sign of a malicious action being performed on the system. Auditing of such events helps in detection and investigation of such actions.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Any Attempts to Run restorecon</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect any execution attempt
of the <tt>restorecon</tt> command for all users and root. If the <tt>auditd</tt>
daemon is configured to use the <tt>augenrules</tt> program to read audit rules
during daemon startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/sbin/restorecon -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F path=/usr/sbin/restorecon -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>
      </td>
      <td xml:lang="en-US">
        Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Ensure auditd Collects Information on the Use of Privileged Commands - userhelper</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect the execution of
privileged commands for all users and root. If the <tt>auditd</tt> daemon is
configured to use the <tt>augenrules</tt> program to read audit rules during
daemon startup (the default), add a line of the following form to a file with
suffix <tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/sbin/userhelper -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the following
form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/sbin/userhelper -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>
      </td>
      <td xml:lang="en-US">
        Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Ensure auditd Collects Information on the Use of Privileged Commands - mount</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect the execution of
privileged commands for all users and root. If the <tt>auditd</tt> daemon is
configured to use the <tt>augenrules</tt> program to read audit rules during
daemon startup (the default), add a line of the following form to a file with
suffix <tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/bin/mount -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the following
form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/bin/mount -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>
      </td>
      <td xml:lang="en-US">
        Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Unsuccessful Creation Attempts to Files - open_by_handle_at O_CREAT</td>
      <td xml:lang="en-US">
        The audit system should collect unauthorized file accesses for
all users and root. The <tt>open_by_handle_at</tt> syscall can be used to create new files
when O_CREAT flag is specified.

The following auidt rules will asure that unsuccessful attempts to create a
file via <tt>open_by_handle_at</tt> syscall are collected.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
rules below to a file with suffix <tt>.rules</tt> in the directory
<tt>/etc/audit/rules.d</tt>.

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the rules below to
<tt>/etc/audit/audit.rules</tt> file.
<pre>
-a always,exit -F arch=b32 -S open_by_handle_at -F a2&amp;0100 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b32 -S open_by_handle_at -F a2&amp;0100 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S open_by_handle_at -F a2&amp;0100 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b64 -S open_by_handle_at -F a2&amp;0100 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
</pre>
      </td>
      <td xml:lang="en-US">
        Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Ensure auditd Rules For Unauthorized Attempts To openat Are Ordered Correctly</td>
      <td xml:lang="en-US">
        The audit system should collect detailed unauthorized file
accesses for all users and root.
To correctly identify unsuccessful creation, unsuccessful modification and unsuccessful access
of files via <tt>openat</tt> syscall the audit rules collecting these events need to be in certain order.
The more specific rules need to come before the less specific rules. The reason for that is that more
specific rules cover a subset of events covered in the less specific rules, thus, they need to come
before to not be overshadowed by less specific rules, which match a bigger set of events.
Make sure that rules for unsuccessful calls of <tt>openat</tt> syscall are in the order shown below.
If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), check the order of
rules below in a file with suffix <tt>.rules</tt> in the directory
<tt>/etc/audit/rules.d</tt>.
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, check the order of rules below in
<tt>/etc/audit/audit.rules</tt> file.
<pre>
-a always,exit -F arch=b32 -S openat -F a2&amp;0100 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b32 -S openat -F a2&amp;0100 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b32 -S openat -F a2&amp;01003 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b32 -S openat -F a2&amp;01003 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b32 -S openat -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-access
-a always,exit -F arch=b32 -S openat -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-access
</pre>
If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S openat -F a2&amp;0100 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b64 -S openat -F a2&amp;0100 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b64 -S openat -F a2&amp;01003 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b64 -S openat -F a2&amp;01003 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b64 -S openat -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-access
-a always,exit -F arch=b64 -S openat -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-access
</pre>
      </td>
      <td xml:lang="en-US">
        The more specific rules cover a subset of events covered by the less specific rules.
By ordering them from more specific to less specific, it is assured that the less specific
rule will not catch events better recorded by the more specific rule.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Events that Modify User/Group Information via openat syscall - /etc/gshadow</td>
      <td xml:lang="en-US">
        The audit system should collect write events to /etc/gshadow file for all users and root.
If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S openat -F a2&amp;03 -F path=/etc/gshadow -F auid>=1000 -F auid!=unset -F key=user-modify</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S openat -F a2&amp;03 -F path=/etc/gshadow -F auid>=1000 -F auid!=unset -F key=user-modify</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S openat -F a2&amp;03 -F path=/etc/gshadow -F auid>=1000 -F auid!=unset -F key=user-modify</pre>
      </td>
      <td xml:lang="en-US">
        Creation of users through direct edition of /etc/gshadow could be an indicator of malicious activity on a system.
Auditing these events could serve as evidence of potential system compromise.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Configure auditd to use audispd's syslog plugin</td>
      <td xml:lang="en-US">
        To configure the <tt>auditd</tt> service to use the
<tt>syslog</tt> plug-in of the <tt>audispd</tt> audit event multiplexor, set
the <tt>active</tt> line in <tt>/etc/audisp/plugins.d/syslog.conf</tt> to <tt>yes</tt>.
Restart the <tt>auditd</tt> service:
<pre>$ sudo service auditd restart</pre>
      </td>
      <td xml:lang="en-US">
        The auditd service does not include the ability to send audit
records to a centralized server for management directly. It does, however,
include a plug-in for audit event multiplexor (audispd) to pass audit records
to the local syslog server.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Configure auditing of unsuccessful ownership changes (ppc64le)</td>
      <td xml:lang="en-US">
        Ensure that unsuccessful attempts to change an ownership of files or directories are audited.

The following rules configure audit as described above:
<pre>## Unsuccessful ownership change
-a always,exit -F arch=b64 -S lchown,fchown,chown,fchownat -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-owner-change
-a always,exit -F arch=b64 -S lchown,fchown,chown,fchownat -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-owner-change    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are alligned with your needs.
      </td>
      <td xml:lang="en-US">
        Unsuccessful attempts to change an ownership of files or directories might be signs of a malicious activity. Having such events audited helps in monitoring and investigation of such activities.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Events that Modify the System's Discretionary Access Controls - lchown</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect file permission
changes for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following line to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S lchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S lchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S lchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S lchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
      </td>
      <td xml:lang="en-US">
        The changing of file permissions could indicate that a user is attempting to
gain access to information that would otherwise be disallowed. Auditing DAC modifications
can facilitate the identification of patterns of abuse among both authorized and
unauthorized users.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Events that Modify the System's Discretionary Access Controls - fchownat</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect file permission
changes for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following line to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S fchownat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S fchownat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S fchownat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S fchownat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
      </td>
      <td xml:lang="en-US">
        The changing of file permissions could indicate that a user is attempting to
gain access to information that would otherwise be disallowed. Auditing DAC modifications
can facilitate the identification of patterns of abuse among both authorized and
unauthorized users.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Events that Modify the System's Mandatory Access Controls in usr/share</td>
      <td xml:lang="en-US">
        If the <tt>auditd</tt> daemon is configured to use the
<tt>augenrules</tt> program to read audit rules during daemon startup (the
default), add the following line to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>:
<pre>-w /usr/share/selinux/ -p wa -k MAC-policy</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-w /usr/share/selinux/ -p wa -k MAC-policy</pre>
      </td>
      <td xml:lang="en-US">
        The system's mandatory access policy (SELinux) should not be
arbitrarily changed by anything other than administrator action. All changes to
MAC policy should be audited.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Ensure auditd Collects Information on the Use of Privileged Commands - sudoedit</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect the execution of
privileged commands for all users and root. If the <tt>auditd</tt> daemon is
configured to use the <tt>augenrules</tt> program to read audit rules during
daemon startup (the default), add a line of the following form to a file with
suffix <tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/bin/sudoedit -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the following
form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/bin/sudoedit -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>
      </td>
      <td xml:lang="en-US">
        Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Events that Modify the System's Discretionary Access Controls - fremovexattr</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect file permission
changes for all users and root.
<br /><br />
If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following line to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S fremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
<br /><br />
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S fremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
<br /><br />
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S fremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
<br /><br />
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S fremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
      </td>
      <td xml:lang="en-US">
        The changing of file permissions could indicate that a user is attempting to
gain access to information that would otherwise be disallowed. Auditing DAC modifications
can facilitate the identification of patterns of abuse among both authorized and
unauthorized users.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Events that Modify User/Group Information via openat syscall - /etc/passwd</td>
      <td xml:lang="en-US">
        The audit system should collect write events to /etc/passwd file for all users and root.
If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S openat -F a2&amp;03 -F path=/etc/passwd -F auid>=1000 -F auid!=unset -F key=modify</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S openat -F a2&amp;03 -F path=/etc/passwd -F auid>=1000 -F auid!=unset -F key=modify</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S openat -F a2&amp;03 -F path=/etc/passwd -F auid>=1000 -F auid!=unset -F key=modify</pre>
      </td>
      <td xml:lang="en-US">
        Creation of users through direct edition of /etc/passwd could be an indicator of malicious activity on a system.
Auditing these events could serve as evidence of potential system compromise.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Configure auditing of unsuccessful file accesses (ppc64le)</td>
      <td xml:lang="en-US">
        Ensure that unsuccessful attempts to access a file are audited.

The following rules configure audit as described above:
<pre>## Unsuccessful file access (any other opens) This has to go last.
-a always,exit -F arch=b64 -S open,openat,openat2,open_by_handle_at -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-access
-a always,exit -F arch=b64 -S open,openat,openat2,open_by_handle_at -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-access    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are alligned with your needs.
      </td>
      <td xml:lang="en-US">
        Unsuccessful attempts to access a file might be signs of malicious activity happening within the system. Auditing of such activities helps in their monitoring and investigation.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Events that Modify the System's Discretionary Access Controls - chmod</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect file permission
changes for all users and root. If the <tt>auditd</tt> daemon is configured to
use the <tt>augenrules</tt> program to read audit rules during daemon startup
(the default), add the following line to a file with suffix <tt>.rules</tt> in
the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S chmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S chmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S chmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S chmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
      </td>
      <td xml:lang="en-US">
        The changing of file permissions could indicate that a user is attempting to
gain access to information that would otherwise be disallowed. Auditing DAC modifications
can facilitate the identification of patterns of abuse among both authorized and
unauthorized users.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Ensure auditd Collects Information on the Use of Privileged Commands - unix_chkpwd</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect the execution of
privileged commands for all users and root. If the <tt>auditd</tt> daemon is
configured to use the <tt>augenrules</tt> program to read audit rules during
daemon startup (the default), add a line of the following form to a file with
suffix <tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/sbin/unix_chkpwd -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the following
form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/sbin/unix_chkpwd -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>
      </td>
      <td xml:lang="en-US">
        Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Ensure auditd Collects Information on the Use of Privileged Commands - gpasswd</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect the execution of
privileged commands for all users and root. If the <tt>auditd</tt> daemon is
configured to use the <tt>augenrules</tt> program to read audit rules during
daemon startup (the default), add a line of the following form to a file with
suffix <tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/bin/gpasswd -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the following
form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/bin/gpasswd -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>
      </td>
      <td xml:lang="en-US">
        Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Configure auditing of successful permission changes (ppc64le)</td>
      <td xml:lang="en-US">
        Ensure that successful attempts to modify permissions of files or directories are audited.

The following rules configure audit as described above:
<pre>## Successful permission change
-a always,exit -F arch=b64 -S chmod,fchmod,fchmodat,setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-perm-change    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are alligned with your needs.
      </td>
      <td xml:lang="en-US">
        Auditing successful file or directory permission changes helps in monitoring and investigating of activities performed on the system.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Configure auditing of unsuccessful file deletions (AArch64)</td>
      <td xml:lang="en-US">
        Ensure that unsuccessful attempts to delete a file are audited.

The following rules configure audit as described above:
<pre>## Unsuccessful file delete
-a always,exit -F arch=b32 -S unlink,unlinkat,rename,renameat -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-delete
-a always,exit -F arch=b64 -S unlinkat,renameat -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-delete
-a always,exit -F arch=b32 -S unlink,unlinkat,rename,renameat -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-delete
-a always,exit -F arch=b64 -S unlinkat,renameat -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-delete    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are alligned with your needs.
      </td>
      <td xml:lang="en-US">
        Unsuccessful attempts to delete a file might be signs of malicious activities. Auditing of such events help in monitoring and investigating of such activities.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Configure auditing of unsuccessful file modifications (ppc64le)</td>
      <td xml:lang="en-US">
        Ensure that unsuccessful attempts to modify a file are audited.

The following rules configure audit as described above:
<pre>## Unsuccessful file modifications (open for write or truncate)
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;01003 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b64 -S open -F a1&amp;01003 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b64 -S truncate,ftruncate -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;01003 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b64 -S open -F a1&amp;01003 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b64 -S truncate,ftruncate -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-modification    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are alligned with your needs.
      </td>
      <td xml:lang="en-US">
        Unsuccessful file modifications might be a sign of a malicious action being performed on the system. Auditing of such events helps in detection and investigation of such actions.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Unsuccessful Delete Attempts to Files - unlink</td>
      <td xml:lang="en-US">
        
The audit system should collect unsuccessful file deletion
attempts for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>.

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file.
<pre>-a always,exit -F arch=b32 -S unlink -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete
-a always,exit -F arch=b32 -S unlink -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S unlink -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete
-a always,exit -F arch=b64 -S unlink -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete</pre>
      </td>
      <td xml:lang="en-US">
        Unsuccessful attempts to delete files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Unsuccessful Modification Attempts to Files - open_by_handle_at O_TRUNC_WRITE</td>
      <td xml:lang="en-US">
        The audit system should collect detailed unauthorized file accesses for
all users and root. The <tt>open_by_handle_at</tt> syscall can be used to modify files
if called for write operation of with O_TRUNC_WRITE flag.

The following auidt rules will asure that unsuccessful attempts to modify a
file via <tt>open_by_handle_at</tt> syscall are collected.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
rules below to a file with suffix <tt>.rules</tt> in the directory
<tt>/etc/audit/rules.d</tt>.

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the rules below to
<tt>/etc/audit/audit.rules</tt> file.
<pre>
-a always,exit -F arch=b32 -S open_by_handle_at -F a2&amp;01003 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b32 -S open_by_handle_at -F a2&amp;01003 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S open_by_handle_at -F a2&amp;01003 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b64 -S open_by_handle_at -F a2&amp;01003 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
</pre>
      </td>
      <td xml:lang="en-US">
        Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Events that Modify User/Group Information - /etc/group</td>
      <td xml:lang="en-US">
        If the <tt>auditd</tt> daemon is configured to use the
<tt>augenrules</tt> program to read audit rules during daemon startup (the
default), add the following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>, in order to capture events that modify
account changes:
<br /><br />
<pre>-w /etc/group -p wa -k audit_rules_usergroup_modification</pre>
<br /><br />
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file, in order to capture events that modify
account changes:
<br /><br />
<pre>-w /etc/group -p wa -k audit_rules_usergroup_modification</pre>
      </td>
      <td xml:lang="en-US">
        In addition to auditing new user and group accounts, these watches
will alert the system administrator(s) to any modifications. Any unexpected
users, groups, or modifications should be investigated for legitimacy.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Events that Modify User/Group Information via open syscall - /etc/passwd</td>
      <td xml:lang="en-US">
        The audit system should collect write events to /etc/passwd file for all users and root.
If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S open -F a1&amp;03 -F path=/etc/passwd -F auid>=1000 -F auid!=unset -F key=modify</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S open -F a1&amp;03 -F path=/etc/passwd -F auid>=1000 -F auid!=unset -F key=modify</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S open -F a1&amp;03 -F path=/etc/passwd -F auid>=1000 -F auid!=unset -F key=modify</pre>
      </td>
      <td xml:lang="en-US">
        Creation of users through direct edition of /etc/passwd could be an indicator of malicious activity on a system.
Auditing these events could serve as evidence of potential system compromise.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Ensure auditd Collects File Deletion Events by User - unlink</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect file deletion events
for all users and root. If the <tt>auditd</tt> daemon is configured to use the
<tt>augenrules</tt> program to read audit rules during daemon startup (the
default), add the following line to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>, setting ARCH to either b32 or b64 as
appropriate for your system:
<pre>-a always,exit -F arch=ARCH -S unlink -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file, setting ARCH to either b32 or b64 as
appropriate for your system:
<pre>-a always,exit -F arch=ARCH -S unlink -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>
      </td>
      <td xml:lang="en-US">
        Auditing file deletions will create an audit trail for files that are removed
from the system. The audit trail could aid in system troubleshooting, as well as, detecting
malicious processes that attempt to delete log files to conceal their presence.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Any Attempts to Run seunshare</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect any execution attempt
of the <tt>seunshare</tt> command for all users and root. If the <tt>auditd</tt>
daemon is configured to use the <tt>augenrules</tt> program to read audit rules
during daemon startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/sbin/seunshare -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F path=/usr/sbin/seunshare -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>
      </td>
      <td xml:lang="en-US">
        Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Unsuccessful Access Attempts to Files - open_by_handle_at</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect unauthorized file
accesses for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S open_by_handle_at -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b32 -S open_by_handle_at -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>
If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S open_by_handle_at -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b64 -S open_by_handle_at -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S open_by_handle_at,truncate,ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b32 -S open_by_handle_at,truncate,ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>
If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S open_by_handle_at,truncate,ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b64 -S open_by_handle_at,truncate,ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>
      </td>
      <td xml:lang="en-US">
        Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Configure auditing of unsuccessful file modifications</td>
      <td xml:lang="en-US">
        Ensure that unsuccessful attempts to modify a file are audited.

The following rules configure audit as described above:
<pre>## Unsuccessful file modifications (open for write or truncate)
-a always,exit -F arch=b32 -S openat,open_by_handle_at -F a2&amp;01003 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;01003 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b32 -S open -F a1&amp;01003 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b64 -S open -F a1&amp;01003 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b32 -S truncate,ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b64 -S truncate,ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b32 -S openat,open_by_handle_at -F a2&amp;01003 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;01003 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b32 -S open -F a1&amp;01003 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b64 -S open -F a1&amp;01003 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b32 -S truncate,ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b64 -S truncate,ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-modification    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are alligned with your needs.
      </td>
      <td xml:lang="en-US">
        Unsuccessful file modifications might be a sign of a malicious action being performed on the system. Auditing of such events helps in detection and investigation of such actions.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Ensure auditd Unauthorized Access Attempts To open_by_handle_at Are Ordered Correctly</td>
      <td xml:lang="en-US">
        The audit system should collect detailed unauthorized file
accesses for all users and root.
To correctly identify unsuccessful creation, unsuccessful modification and unsuccessful access
of files via <tt>open_by_handle_at</tt> syscall the audit rules collecting these events need to be in certain order.
The more specific rules need to come before the less specific rules. The reason for that is that more
specific rules cover a subset of events covered in the less specific rules, thus, they need to come
before to not be overshadowed by less specific rules, which match a bigger set of events.
Make sure that rules for unsuccessful calls of <tt>open_by_handle_at</tt> syscall are in the order shown below.
If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), check the order of
rules below in a file with suffix <tt>.rules</tt> in the directory
<tt>/etc/audit/rules.d</tt>.
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, check the order of rules below in
<tt>/etc/audit/audit.rules</tt> file.
<pre>
-a always,exit -F arch=b32 -S open_by_handle_at -F a2&amp;0100 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b32 -S open_by_handle_at -F a2&amp;0100 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b32 -S open_by_handle_at -F a2&amp;01003 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b32 -S open_by_handle_at -F a2&amp;01003 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b32 -S open_by_handle_at -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-access
-a always,exit -F arch=b32 -S open_by_handle_at -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-access
</pre>
If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S open_by_handle_at -F a2&amp;0100 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b64 -S open_by_handle_at -F a2&amp;0100 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b64 -S open_by_handle_at -F a2&amp;01003 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b64 -S open_by_handle_at -F a2&amp;01003 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b64 -S open_by_handle_at -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-access
-a always,exit -F arch=b64 -S open_by_handle_at -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-access
</pre>
      </td>
      <td xml:lang="en-US">
        The more specific rules cover a subset of events covered by the less specific rules.
By ordering them from more specific to less specific, it is assured that the less specific
rule will not catch events better recorded by the more specific rule.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Events that Modify User/Group Information via open syscall - /etc/gshadow</td>
      <td xml:lang="en-US">
        The audit system should collect write events to /etc/gshadow file for all users and root.
If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S open -F a1&amp;03 -F path=/etc/gshadow -F auid>=1000 -F auid!=unset -F key=user-modify</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S open -F a1&amp;03 -F path=/etc/gshadow -F auid>=1000 -F auid!=unset -F key=user-modify</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S open -F a1&amp;03 -F path=/etc/gshadow -F auid>=1000 -F auid!=unset -F key=user-modify</pre>
      </td>
      <td xml:lang="en-US">
        Creation of users through direct edition of /etc/gshadow could be an indicator of malicious activity on a system.
Auditing these events could serve as evidence of potential system compromise.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Unsuccessful Access Attempts to Files - openat</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect unauthorized file
accesses for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S openat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b32 -S openat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S openat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b64 -S openat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S openat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b32 -S openat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S openat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b64 -S openat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>
      </td>
      <td xml:lang="en-US">
        Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Unsuccessful Access Attempts to Files - open</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect unauthorized file
accesses for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S open -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b32 -S open -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S open -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b64 -S open -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S open -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b32 -S open -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S open -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b64 -S open -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>
      </td>
      <td xml:lang="en-US">
        Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Events that Modify User/Group Information via openat syscall - /etc/shadow</td>
      <td xml:lang="en-US">
        The audit system should collect write events to /etc/shadow file for all users and root.
If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S openat -F a2&amp;03 -F path=/etc/shadow -F auid>=1000 -F auid!=unset -F key=user-modify</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S openat -F a2&amp;03 -F path=/etc/shadow -F auid>=1000 -F auid!=unset -F key=user-modify</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S openat -F a2&amp;03 -F path=/etc/shadow -F auid>=1000 -F auid!=unset -F key=user-modify</pre>
      </td>
      <td xml:lang="en-US">
        Creation of users through direct edition of /etc/shadow could be an indicator of malicious activity on a system.
Auditing these events could serve as evidence of potential system compromise.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Ensure auditd Collects File Deletion Events by User - rename</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect file deletion events
for all users and root. If the <tt>auditd</tt> daemon is configured to use the
<tt>augenrules</tt> program to read audit rules during daemon startup (the
default), add the following line to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>, setting ARCH to either b32 or b64 as
appropriate for your system:
<pre>-a always,exit -F arch=ARCH -S rename -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file, setting ARCH to either b32 or b64 as
appropriate for your system:
<pre>-a always,exit -F arch=ARCH -S rename -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>
      </td>
      <td xml:lang="en-US">
        Auditing file deletions will create an audit trail for files that are removed
from the system. The audit trail could aid in system troubleshooting, as well as, detecting
malicious processes that attempt to delete log files to conceal their presence.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Configure auditing of successful file accesses</td>
      <td xml:lang="en-US">
        Ensure that successful attempts to access a file are audited.

The following rules configure audit as described above:
<pre>## Successful file access (any other opens) This has to go last.
## These next two are likely to result in a whole lot of events
-a always,exit -F arch=b32 -S open,openat,openat2,open_by_handle_at -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-access
-a always,exit -F arch=b64 -S open,openat,openat2,open_by_handle_at -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-access    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are alligned with your needs.
      </td>
      <td xml:lang="en-US">
        Auditing of successful attempts to access a file helps in investigation of activities performed on the system.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Events that Modify the System's Discretionary Access Controls - setxattr</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect file permission
changes for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following line to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S setxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S setxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S setxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S setxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
      </td>
      <td xml:lang="en-US">
        The changing of file permissions could indicate that a user is attempting to
gain access to information that would otherwise be disallowed. Auditing DAC modifications
can facilitate the identification of patterns of abuse among both authorized and
unauthorized users.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Configure auditing of successful file modifications (ppc64le)</td>
      <td xml:lang="en-US">
        Ensure that successful attempts to modify a file are audited.

The following rules configure audit as described above:
<pre>## Successful file modifications (open for write or truncate)
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;01003 -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-modification
-a always,exit -F arch=b64 -S open -F a1&amp;01003 -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-modification
-a always,exit -F arch=b64 -S truncate,ftruncate -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-modification    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are alligned with your needs.
      </td>
      <td xml:lang="en-US">
        Auditing of successful attempts to modify a file helps in investigation of actions which happened on the system.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Configure auditing of successful file deletions</td>
      <td xml:lang="en-US">
        Ensure that successful attempts to delete a file are audited.

The following rules configure audit as described above:
<pre>## Successful file delete
-a always,exit -F arch=b32 -S unlink,unlinkat,rename,renameat -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-delete
-a always,exit -F arch=b64 -S unlink,unlinkat,rename,renameat -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-delete    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are alligned with your needs.
      </td>
      <td xml:lang="en-US">
        Auditing of successful attempts to delete a file may help in monitoring and investigation of activities performed on the system.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Events that Modify User/Group Information - /etc/passwd</td>
      <td xml:lang="en-US">
        If the <tt>auditd</tt> daemon is configured to use the
<tt>augenrules</tt> program to read audit rules during daemon startup (the
default), add the following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>, in order to capture events that modify
account changes:
<br /><br />
<pre>-w /etc/passwd -p wa -k audit_rules_usergroup_modification</pre>
<br /><br />
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file, in order to capture events that modify
account changes:
<br /><br />
<pre>-w /etc/passwd -p wa -k audit_rules_usergroup_modification</pre>
      </td>
      <td xml:lang="en-US">
        In addition to auditing new user and group accounts, these watches
will alert the system administrator(s) to any modifications. Any unexpected
users, groups, or modifications should be investigated for legitimacy.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Ensure auditd Collects Information on the Use of Privileged Commands - unix2_chkpwd</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect the execution of
privileged commands for all users and root. If the <tt>auditd</tt> daemon is
configured to use the <tt>augenrules</tt> program to read audit rules during
daemon startup (the default), add a line of the following form to a file with
suffix <tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/sbin/unix2_chkpwd -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the following
form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/sbin/unix2_chkpwd -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>
      </td>
      <td xml:lang="en-US">
        Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Ensure auditd Collects System Administrator Actions</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect administrator actions
for all users and root. If the <tt>auditd</tt> daemon is configured to use the
<tt>augenrules</tt> program to read audit rules during daemon startup (the default),
add the following line to a file with suffix <tt>.rules</tt> in the directory
<tt>/etc/audit/rules.d</tt>:
<pre>-w /etc/sudoers -p wa -k actions
-w /etc/sudoers.d/ -p wa -k actions</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-w /etc/sudoers -p wa -k actions
-w /etc/sudoers.d/ -p wa -k actions</pre>
      </td>
      <td xml:lang="en-US">
        The actions taken by system administrators should be audited to keep a record
of what was executed on the system, as well as, for accountability purposes.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Perform general configuration of Audit for OSPP (ppc64le)</td>
      <td xml:lang="en-US">
        Configure some basic <tt>Audit</tt> parameters specific for OSPP profile.
In particular, configure <tt>Audit</tt> to watch for direct modification of files storing system user and group information, and usage of applications with special rights which can change system configuration.
Further audited events include access to audit log it self, attempts to Alter Process and Session Initiation Information, and attempts to modify MAC controls.

The following rules configure audit as described above:
<pre>## The purpose of these rules is to meet the requirements for Operating
## System Protection Profile (OSPP)v4.2. These rules depends on having
## the following rule files copied to /etc/audit/rules.d:
##
## 10-base-config.rules, 11-loginuid.rules,
## 30-ospp-v42-1-create-failed.rules, 30-ospp-v42-1-create-success.rules,
## 30-ospp-v42-2-modify-failed.rules, 30-ospp-v42-2-modify-success.rules,
## 30-ospp-v42-3-access-failed.rules, 30-ospp-v42-3-access-success.rules,
## 30-ospp-v42-4-delete-failed.rules, 30-ospp-v42-4-delete-success.rules,
## 30-ospp-v42-5-perm-change-failed.rules,
## 30-ospp-v42-5-perm-change-success.rules,
## 30-ospp-v42-6-owner-change-failed.rules,
## 30-ospp-v42-6-owner-change-success.rules
##
## original copies may be found in /usr/share/audit/sample-rules/


## User add delete modify. This is covered by pam. However, someone could
## open a file and directly create or modify a user, so we'll watch passwd and
## shadow for writes
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;03 -F path=/etc/passwd -F auid>=1000 -F auid!=unset -F key=user-modify
-a always,exit -F arch=b64 -S open -F a1&amp;03 -F path=/etc/passwd -F auid>=1000 -F auid!=unset -F key=user-modify
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;03 -F path=/etc/shadow -F auid>=1000 -F auid!=unset -F key=user-modify
-a always,exit -F arch=b64 -S open -F a1&amp;03 -F path=/etc/shadow -F auid>=1000 -F auid!=unset -F key=user-modify

## User enable and disable. This is entirely handled by pam.

## Group add delete modify. This is covered by pam. However, someone could
## open a file and directly create or modify a user, so we'll watch group and
## gshadow for writes
-a always,exit -F path=/etc/passwd -F perm=wa -F auid>=1000 -F auid!=unset -F key=user-modify
-a always,exit -F path=/etc/shadow -F perm=wa -F auid>=1000 -F auid!=unset -F key=user-modify
-a always,exit -F path=/etc/group -F perm=wa -F auid>=1000 -F auid!=unset -F key=group-modify
-a always,exit -F path=/etc/gshadow -F perm=wa -F auid>=1000 -F auid!=unset -F key=group-modify


## Use of special rights for config changes. This would be use of setuid
## programs that relate to user accts. This is not all setuid apps because
## requirements are only for ones that affect system configuration.
-a always,exit -F path=/usr/sbin/unix_chkpwd -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F path=/usr/sbin/usernetctl -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F path=/usr/sbin/userhelper -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F path=/usr/sbin/seunshare -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F path=/usr/bin/mount -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F path=/usr/bin/newgrp -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F path=/usr/bin/newuidmap -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F path=/usr/bin/gpasswd -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F path=/usr/bin/newgidmap -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F path=/usr/bin/umount -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F path=/usr/bin/passwd -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F path=/usr/bin/crontab -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F path=/usr/bin/at -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F path=/usr/sbin/grub2-set-bootflag -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes

## Privilege escalation via su or sudo. This is entirely handled by pam.
## Special case for systemd-run. It is not audit aware, specifically watch it
-a always,exit -F path=/usr/bin/systemd-run -F perm=x -F auid!=unset -F key=maybe-escalation
## Special case for pkexec. It is not audit aware, specifically watch it
-a always,exit -F path=/usr/bin/pkexec -F perm=x -F key=maybe-escalation


## Watch for configuration changes to privilege escalation.
-a always,exit -F path=/etc/sudoers -F perm=wa -F key=special-config-changes
-a always,exit -F dir=/etc/sudoers.d/ -F perm=wa -F key=special-config-changes

## Audit log access
-a always,exit -F dir=/var/log/audit/ -F perm=r -F auid>=1000 -F auid!=unset -F key=access-audit-trail
## Attempts to Alter Process and Session Initiation Information
-a always,exit -F path=/var/run/utmp -F perm=wa -F auid>=1000 -F auid!=unset -F key=session
-a always,exit -F path=/var/log/btmp -F perm=wa -F auid>=1000 -F auid!=unset -F key=session
-a always,exit -F path=/var/log/wtmp -F perm=wa -F auid>=1000 -F auid!=unset -F key=session

## Attempts to modify MAC controls
-a always,exit -F dir=/etc/selinux/ -F perm=wa -F auid>=1000 -F auid!=unset -F key=MAC-policy

## Software updates. This is entirely handled by rpm.

## System start and shutdown. This is entirely handled by systemd

## Kernel Module loading. This is handled in 43-module-load.rules

## Application invocation. The requirements list an optional requirement
## FPT_SRP_EXT.1 Software Restriction Policies. This event is intended to
## state results from that policy. This would be handled entirely by
## that daemon.    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are alligned with your needs.
      </td>
      <td xml:lang="en-US">
        Auditing of events listed in the description provides data for monitoring and investigation of potentially malicious events e.g. tampering with <tt>Audit</tt> logs, malicious access to files storing information about system users and groups etc.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Configure auditing of unsuccessful file accesses (AArch64)</td>
      <td xml:lang="en-US">
        Ensure that unsuccessful attempts to access a file are audited.

The following rules configure audit as described above:
<pre>## Unsuccessful file access (any other opens) This has to go last.
-a always,exit -F arch=b32 -S open,openat,openat2,open_by_handle_at -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-access
-a always,exit -F arch=b64 -S openat,openat2,open_by_handle_at -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-access
-a always,exit -F arch=b32 -S open,openat,openat2,open_by_handle_at -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-access
-a always,exit -F arch=b64 -S openat,openat2,open_by_handle_at -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-access    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are alligned with your needs.
      </td>
      <td xml:lang="en-US">
        Unsuccessful attempts to access a file might be signs of malicious activity happening within the system. Auditing of such activities helps in their monitoring and investigation.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Events that Modify the System's Discretionary Access Controls - chown</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect file permission
changes for all users and root. If the <tt>auditd</tt> daemon is configured to
use the <tt>augenrules</tt> program to read audit rules during daemon startup
(the default), add the following line to a file with suffix <tt>.rules</tt> in
the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S chown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S chown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S chown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S chown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
      </td>
      <td xml:lang="en-US">
        The changing of file permissions could indicate that a user is attempting to
gain access to information that would otherwise be disallowed. Auditing DAC modifications
can facilitate the identification of patterns of abuse among both authorized and
unauthorized users.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Unsuccessful Delete Attempts to Files - rename</td>
      <td xml:lang="en-US">
        The audit system should collect unsuccessful file deletion
attempts for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>.
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file.
<pre>-a always,exit -F arch=b32 -S rename -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete
-a always,exit -F arch=b32 -S rename -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete</pre>
If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S rename -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete
-a always,exit -F arch=b64 -S rename -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete</pre>
      </td>
      <td xml:lang="en-US">
        Unsuccessful attempts to delete files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Perform general configuration of Audit for OSPP (AArch64)</td>
      <td xml:lang="en-US">
        Configure some basic <tt>Audit</tt> parameters specific for OSPP profile.
In particular, configure <tt>Audit</tt> to watch for direct modification of files storing system user and group information, and usage of applications with special rights which can change system configuration.
Further audited events include access to audit log it self, attempts to Alter Process and Session Initiation Information, and attempts to modify MAC controls.

The following rules configure audit as described above:
<pre>## The purpose of these rules is to meet the requirements for Operating
## System Protection Profile (OSPP)v4.2. These rules depends on having
## the following rule files copied to /etc/audit/rules.d:
##
## 10-base-config.rules, 11-loginuid.rules,
## 30-ospp-v42-1-create-failed.rules, 30-ospp-v42-1-create-success.rules,
## 30-ospp-v42-2-modify-failed.rules, 30-ospp-v42-2-modify-success.rules,
## 30-ospp-v42-3-access-failed.rules, 30-ospp-v42-3-access-success.rules,
## 30-ospp-v42-4-delete-failed.rules, 30-ospp-v42-4-delete-success.rules,
## 30-ospp-v42-5-perm-change-failed.rules,
## 30-ospp-v42-5-perm-change-success.rules,
## 30-ospp-v42-6-owner-change-failed.rules,
## 30-ospp-v42-6-owner-change-success.rules
##
## original copies may be found in /usr/share/audit/sample-rules/


## User add delete modify. This is covered by pam. However, someone could
## open a file and directly create or modify a user, so we'll watch passwd and
## shadow for writes
-a always,exit -F arch=b32 -S openat,open_by_handle_at -F a2&amp;03 -F path=/etc/passwd -F auid>=1000 -F auid!=unset -F key=user-modify
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;03 -F path=/etc/passwd -F auid>=1000 -F auid!=unset -F key=user-modify
-a always,exit -F arch=b32 -S open -F a1&amp;03 -F path=/etc/passwd -F auid>=1000 -F auid!=unset -F key=user-modify
-a always,exit -F arch=b32 -S openat,open_by_handle_at -F a2&amp;03 -F path=/etc/shadow -F auid>=1000 -F auid!=unset -F key=user-modify
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;03 -F path=/etc/shadow -F auid>=1000 -F auid!=unset -F key=user-modify
-a always,exit -F arch=b32 -S open -F a1&amp;03 -F path=/etc/shadow -F auid>=1000 -F auid!=unset -F key=user-modify

## User enable and disable. This is entirely handled by pam.

## Group add delete modify. This is covered by pam. However, someone could
## open a file and directly create or modify a user, so we'll watch group and
## gshadow for writes
-a always,exit -F path=/etc/passwd -F perm=wa -F auid>=1000 -F auid!=unset -F key=user-modify
-a always,exit -F path=/etc/shadow -F perm=wa -F auid>=1000 -F auid!=unset -F key=user-modify
-a always,exit -F path=/etc/group -F perm=wa -F auid>=1000 -F auid!=unset -F key=group-modify
-a always,exit -F path=/etc/gshadow -F perm=wa -F auid>=1000 -F auid!=unset -F key=group-modify


## Use of special rights for config changes. This would be use of setuid
## programs that relate to user accts. This is not all setuid apps because
## requirements are only for ones that affect system configuration.
-a always,exit -F path=/usr/sbin/unix_chkpwd -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F path=/usr/sbin/usernetctl -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F path=/usr/sbin/userhelper -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F path=/usr/sbin/seunshare -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F path=/usr/bin/mount -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F path=/usr/bin/newgrp -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F path=/usr/bin/newuidmap -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F path=/usr/bin/gpasswd -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F path=/usr/bin/newgidmap -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F path=/usr/bin/umount -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F path=/usr/bin/passwd -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F path=/usr/bin/crontab -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F path=/usr/bin/at -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F path=/usr/sbin/grub2-set-bootflag -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes

## Privilege escalation via su or sudo. This is entirely handled by pam.
## Special case for systemd-run. It is not audit aware, specifically watch it
-a always,exit -F path=/usr/bin/systemd-run -F perm=x -F auid!=unset -F key=maybe-escalation
## Special case for pkexec. It is not audit aware, specifically watch it
-a always,exit -F path=/usr/bin/pkexec -F perm=x -F key=maybe-escalation


## Watch for configuration changes to privilege escalation.
-a always,exit -F path=/etc/sudoers -F perm=wa -F key=special-config-changes
-a always,exit -F dir=/etc/sudoers.d/ -F perm=wa -F key=special-config-changes

## Audit log access
-a always,exit -F dir=/var/log/audit/ -F perm=r -F auid>=1000 -F auid!=unset -F key=access-audit-trail
## Attempts to Alter Process and Session Initiation Information
-a always,exit -F path=/var/run/utmp -F perm=wa -F auid>=1000 -F auid!=unset -F key=session
-a always,exit -F path=/var/log/btmp -F perm=wa -F auid>=1000 -F auid!=unset -F key=session
-a always,exit -F path=/var/log/wtmp -F perm=wa -F auid>=1000 -F auid!=unset -F key=session

## Attempts to modify MAC controls
-a always,exit -F dir=/etc/selinux/ -F perm=wa -F auid>=1000 -F auid!=unset -F key=MAC-policy

## Software updates. This is entirely handled by rpm.

## System start and shutdown. This is entirely handled by systemd

## Kernel Module loading. This is handled in 43-module-load.rules

## Application invocation. The requirements list an optional requirement
## FPT_SRP_EXT.1 Software Restriction Policies. This event is intended to
## state results from that policy. This would be handled entirely by
## that daemon.    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are alligned with your needs.
      </td>
      <td xml:lang="en-US">
        Auditing of events listed in the description provides data for monitoring and investigation of potentially malicious events e.g. tampering with <tt>Audit</tt> logs, malicious access to files storing information about system users and groups etc.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Ensure auditd Collects Information on the Use of Privileged Commands - at</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect the execution of
privileged commands for all users and root. If the <tt>auditd</tt> daemon is
configured to use the <tt>augenrules</tt> program to read audit rules during
daemon startup (the default), add a line of the following form to a file with
suffix <tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/bin/at -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the following
form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/bin/at -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>
      </td>
      <td xml:lang="en-US">
        Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Configure auditing of successful file deletions (AArch64)</td>
      <td xml:lang="en-US">
        Ensure that successful attempts to delete a file are audited.

The following rules configure audit as described above:
<pre>## Successful file delete
-a always,exit -F arch=b32 -S unlink,unlinkat,rename,renameat -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-delete
-a always,exit -F arch=b64 -S unlinkat,renameat -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-delete    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are alligned with your needs.
      </td>
      <td xml:lang="en-US">
        Auditing of successful attempts to delete a file may help in monitoring and investigation of activities performed on the system.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Configure auditing of unsuccessful file deletions (ppc64le)</td>
      <td xml:lang="en-US">
        Ensure that unsuccessful attempts to delete a file are audited.

The following rules configure audit as described above:
<pre>## Unsuccessful file delete
-a always,exit -F arch=b64 -S unlink,unlinkat,rename,renameat -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-delete
-a always,exit -F arch=b64 -S unlink,unlinkat,rename,renameat -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-delete    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are alligned with your needs.
      </td>
      <td xml:lang="en-US">
        Unsuccessful attempts to delete a file might be signs of malicious activities. Auditing of such events help in monitoring and investigating of such activities.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Ensure auditd Collects Information on the Use of Privileged Commands - newuidmap</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect the execution of
privileged commands for all users and root. If the <tt>auditd</tt> daemon is
configured to use the <tt>augenrules</tt> program to read audit rules during
daemon startup (the default), add a line of the following form to a file with
suffix <tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/bin/newuidmap -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the following
form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/bin/newuidmap -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>
      </td>
      <td xml:lang="en-US">
        Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Events that Modify User/Group Information - /etc/security/opasswd</td>
      <td xml:lang="en-US">
        If the <tt>auditd</tt> daemon is configured to use the
<tt>augenrules</tt> program to read audit rules during daemon startup (the
default), add the following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>, in order to capture events that modify
account changes:
<br /><br />
<pre>-w /etc/security/opasswd -p wa -k audit_rules_usergroup_modification</pre>
<br /><br />
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file, in order to capture events that modify
account changes:
<br /><br />
<pre>-w /etc/security/opasswd -p wa -k audit_rules_usergroup_modification</pre>
      </td>
      <td xml:lang="en-US">
        In addition to auditing new user and group accounts, these watches
will alert the system administrator(s) to any modifications. Any unexpected
users, groups, or modifications should be investigated for legitimacy.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Configure auditing of loading and unloading of kernel modules</td>
      <td xml:lang="en-US">
        Ensure that loading and unloading of kernel modules is audited.

The following rules configure audit as described above:
<pre>## These rules watch for kernel module insertion. By monitoring
## the syscall, we do not need any watches on programs.
-a always,exit -F arch=b32 -S init_module,finit_module -F key=module-load
-a always,exit -F arch=b64 -S init_module,finit_module -F key=module-load
-a always,exit -F arch=b32 -S delete_module -F key=module-unload
-a always,exit -F arch=b64 -S delete_module -F key=module-unload    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>
      </td>
      <td xml:lang="en-US">
        Loading of a malicious kernel module introduces a risk to the system, as the module has access to sensitive data and perform actions at the operating system kernel level. Having such events audited helps in monitoring and investigating of malicious activities.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Attempts to Alter Logon and Logout Events - lastlog</td>
      <td xml:lang="en-US">
        The audit system already collects login information for all users
and root. If the <tt>auditd</tt> daemon is configured to use the
<tt>augenrules</tt> program to read audit rules during daemon startup (the
default), add the following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt> in order to watch for attempted manual
edits of files involved in storing logon events:
<pre>-w /var/log/lastlog -p wa -k logins</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file in order to watch for unattempted manual
edits of files involved in storing logon events:
<pre>-w /var/log/lastlog -p wa -k logins</pre>
      </td>
      <td xml:lang="en-US">
        Manual editing of these files may indicate nefarious activity, such
as an attacker attempting to remove evidence of an intrusion.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Unsuccessful Delete Attempts to Files - unlinkat</td>
      <td xml:lang="en-US">
        
The audit system should collect unsuccessful file deletion
attempts for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>.

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file.
<pre>-a always,exit -F arch=b32 -S unlinkat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete
-a always,exit -F arch=b32 -S unlinkat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S unlinkat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete
-a always,exit -F arch=b64 -S unlinkat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete</pre>
      </td>
      <td xml:lang="en-US">
        Unsuccessful attempts to delete files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Events that Modify the System's Discretionary Access Controls - fchmod</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect file permission
changes for all users and root. If the <tt>auditd</tt> daemon is configured to
use the <tt>augenrules</tt> program to read audit rules during daemon startup
(the default), add the following line to a file with suffix <tt>.rules</tt> in
the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S fchmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S fchmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S fchmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S fchmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
      </td>
      <td xml:lang="en-US">
        The changing of file permissions could indicate that a user is attempting to
gain access to information that would otherwise be disallowed. Auditing DAC modifications
can facilitate the identification of patterns of abuse among both authorized and
unauthorized users.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Events that Modify User/Group Information - /etc/shadow</td>
      <td xml:lang="en-US">
        If the <tt>auditd</tt> daemon is configured to use the
<tt>augenrules</tt> program to read audit rules during daemon startup (the
default), add the following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>, in order to capture events that modify
account changes:
<br /><br />
<pre>-w /etc/shadow -p wa -k audit_rules_usergroup_modification</pre>
<br /><br />
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file, in order to capture events that modify
account changes:
<br /><br />
<pre>-w /etc/shadow -p wa -k audit_rules_usergroup_modification</pre>
      </td>
      <td xml:lang="en-US">
        In addition to auditing new user and group accounts, these watches
will alert the system administrator(s) to any modifications. Any unexpected
users, groups, or modifications should be investigated for legitimacy.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Unsuccessful Creation Attempts to Files - open O_CREAT</td>
      <td xml:lang="en-US">
        The audit system should collect unauthorized file accesses for
all users and root. The <tt>open</tt> syscall can be used to create new files
when O_CREAT flag is specified.

The following auidt rules will asure that unsuccessful attempts to create a
file via <tt>open</tt> syscall are collected.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
rules below to a file with suffix <tt>.rules</tt> in the directory
<tt>/etc/audit/rules.d</tt>.

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the rules below to
<tt>/etc/audit/audit.rules</tt> file.
<pre>
-a always,exit -F arch=b32 -S open -F a1&amp;0100 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b32 -S open -F a1&amp;0100 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S open -F a1&amp;0100 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b64 -S open -F a1&amp;0100 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
</pre>
      </td>
      <td xml:lang="en-US">
        Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Access Events to Audit Log Directory</td>
      <td xml:lang="en-US">
        The audit system should collect access events to read audit log directory.
The following audit rule will assure that access to audit log directory are
collected.
<pre>-a always,exit -F dir=/var/log/audit/ -F perm=r -F auid>=1000 -F auid!=unset -F key=access-audit-trail</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
rule to a file with suffix <tt>.rules</tt> in the directory
<tt>/etc/audit/rules.d</tt>.
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the rule to
<tt>/etc/audit/audit.rules</tt> file.
      </td>
      <td xml:lang="en-US">
        Attempts to read the logs should be recorded, suspicious access to audit log files could be an indicator of malicious activity on a system.
Auditing these events could serve as evidence of potential system compromise.'
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Configure auditing of unsuccessful ownership changes (AArch64)</td>
      <td xml:lang="en-US">
        Ensure that unsuccessful attempts to change an ownership of files or directories are audited.

The following rules configure audit as described above:
<pre>## Unsuccessful ownership change
-a always,exit -F arch=b32 -S lchown,fchown,chown,fchownat -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-owner-change
-a always,exit -F arch=b64 -S fchown,fchownat -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-owner-change
-a always,exit -F arch=b32 -S lchown,fchown,chown,fchownat -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-owner-change
-a always,exit -F arch=b64 -S fchown,fchownat -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-owner-change    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are alligned with your needs.
      </td>
      <td xml:lang="en-US">
        Unsuccessful attempts to change an ownership of files or directories might be signs of a malicious activity. Having such events audited helps in monitoring and investigation of such activities.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Configure auditing of unsuccessful file deletions</td>
      <td xml:lang="en-US">
        Ensure that unsuccessful attempts to delete a file are audited.

The following rules configure audit as described above:
<pre>## Unsuccessful file delete
-a always,exit -F arch=b32 -S unlink,unlinkat,rename,renameat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete
-a always,exit -F arch=b64 -S unlink,unlinkat,rename,renameat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete
-a always,exit -F arch=b32 -S unlink,unlinkat,rename,renameat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete
-a always,exit -F arch=b64 -S unlink,unlinkat,rename,renameat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are alligned with your needs.
      </td>
      <td xml:lang="en-US">
        Unsuccessful attempts to delete a file might be signs of malicious activities. Auditing of such events help in monitoring and investigating of such activities.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Unsuccessful Access Attempts to Files - creat</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect unauthorized file
accesses for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S creat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b32 -S creat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>
If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S creat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b64 -S creat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S creat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b32 -S creat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>
If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S creat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b64 -S creat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>
      </td>
      <td xml:lang="en-US">
        Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Events that Modify the System's Discretionary Access Controls - fsetxattr</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect file permission
changes for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following line to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S fsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S fsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S fsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S fsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
      </td>
      <td xml:lang="en-US">
        The changing of file permissions could indicate that a user is attempting to
gain access to information that would otherwise be disallowed. Auditing DAC modifications
can facilitate the identification of patterns of abuse among both authorized and
unauthorized users.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Attempts to Alter Process and Session Initiation Information</td>
      <td xml:lang="en-US">
        The audit system already collects process information for all
users and root. If the <tt>auditd</tt> daemon is configured to use the
<tt>augenrules</tt> program to read audit rules during daemon startup (the
default), add the following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt> in order to watch for attempted manual
edits of files involved in storing such process information:
<pre>-w /var/run/utmp -p wa -k session
-w /var/log/btmp -p wa -k session
-w /var/log/wtmp -p wa -k session</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file in order to watch for attempted manual
edits of files involved in storing such process information:
<pre>-w /var/run/utmp -p wa -k session
-w /var/log/btmp -p wa -k session
-w /var/log/wtmp -p wa -k session</pre>
      </td>
      <td xml:lang="en-US">
        Manual editing of these files may indicate nefarious activity, such
as an attacker attempting to remove evidence of an intrusion.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Configure auditing of unsuccessful permission changes</td>
      <td xml:lang="en-US">
        Ensure that unsuccessful attempts to change file or directory permissions are audited.

The following rules configure audit as described above:
<pre>## Unsuccessful permission change
-a always,exit -F arch=b32 -S chmod,fchmod,fchmodat,setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-perm-change
-a always,exit -F arch=b64 -S chmod,fchmod,fchmodat,setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-perm-change
-a always,exit -F arch=b32 -S chmod,fchmod,fchmodat,setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-perm-change
-a always,exit -F arch=b64 -S chmod,fchmod,fchmodat,setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-perm-change    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are alligned with your needs.
      </td>
      <td xml:lang="en-US">
        Unsuccessful attempts to change permissions of files or directories might be signs of malicious activity. Having such events audited helps in monitoring and investigation of such activities.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Events that Modify the System's Discretionary Access Controls - lremovexattr</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect file permission
changes for all users and root.
<br /><br />
If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following line to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S lremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
<br /><br />
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S lremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
<br /><br />
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S lremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
<br /><br />
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S lremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
      </td>
      <td xml:lang="en-US">
        The changing of file permissions could indicate that a user is attempting to
gain access to information that would otherwise be disallowed. Auditing DAC modifications
can facilitate the identification of patterns of abuse among both authorized and
unauthorized users.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Ensure auditd Collects Information on Kernel Module Unloading - delete_module</td>
      <td xml:lang="en-US">
        To capture kernel module unloading events, use following line, setting ARCH to
either b32 for 32-bit system, or having two lines for both b32 and b64 in case your system is 64-bit:

<pre>-a always,exit -F arch=<i>ARCH</i> -S delete_module -F auid>=1000 -F auid!=unset -F key=modules</pre>


Place to add the line depends on a way <tt>auditd</tt> daemon is configured. If it is configured
to use the <tt>augenrules</tt> program (the default), add the line to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>.

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt> utility,
add the line to file <tt>/etc/audit/audit.rules</tt>.
      </td>
      <td xml:lang="en-US">
        The removal of kernel modules can be used to alter the behavior of
the kernel and potentially introduce malicious code into kernel space. It is important
to have an audit trail of modules that have been introduced into the kernel.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Configure auditing of successful ownership changes</td>
      <td xml:lang="en-US">
        Ensure that successful attempts to change an ownership of files or directories are audited.

The following rules configure audit as described above:
<pre>## Successful ownership change
-a always,exit -F arch=b32 -S lchown,fchown,chown,fchownat -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-owner-change
-a always,exit -F arch=b64 -S lchown,fchown,chown,fchownat -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-owner-change    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are alligned with your needs.
      </td>
      <td xml:lang="en-US">
        Auditing of successful ownership changes of files or directories helps in monitoring or investingating of activities performed on the system.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Configure auditing of unsuccessful file accesses</td>
      <td xml:lang="en-US">
        Ensure that unsuccessful attempts to access a file are audited.

The following rules configure audit as described above:
<pre>## Unsuccessful file access (any other opens) This has to go last.
-a always,exit -F arch=b32 -S open,openat,openat2,open_by_handle_at -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-access
-a always,exit -F arch=b64 -S open,openat,openat2,open_by_handle_at -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-access
-a always,exit -F arch=b32 -S open,openat,openat2,open_by_handle_at -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-access
-a always,exit -F arch=b64 -S open,openat,openat2,open_by_handle_at -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-access    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are alligned with your needs.
      </td>
      <td xml:lang="en-US">
        Unsuccessful attempts to access a file might be signs of malicious activity happening within the system. Auditing of such activities helps in their monitoring and investigation.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Ensure auditd Collects File Deletion Events by User - rmdir</td>
      <td xml:lang="en-US">
        At a minimum, the audit system should collect file deletion events
for all users and root. If the <tt>auditd</tt> daemon is configured to use the
<tt>augenrules</tt> program to read audit rules during daemon startup (the
default), add the following line to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>, setting ARCH to either b32 or b64 as
appropriate for your system:
<pre>-a always,exit -F arch=ARCH -S rmdir -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file, setting ARCH to either b32 or b64 as
appropriate for your system:
<pre>-a always,exit -F arch=ARCH -S rmdir -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>
      </td>
      <td xml:lang="en-US">
        Auditing file deletions will create an audit trail for files that are removed
from the system. The audit trail could aid in system troubleshooting, as well as, detecting
malicious processes that attempt to delete log files to conceal their presence.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Record Unsuccessful Modification Attempts to Files - open O_TRUNC_WRITE</td>
      <td xml:lang="en-US">
        The audit system should collect detailed unauthorized file accesses for
all users and root. The <tt>open</tt> syscall can be used to modify files
if called for write operation of with O_TRUNC_WRITE flag.
The following auidt rules will asure that unsuccessful attempts to modify a
file via <tt>open</tt> syscall are collected.
If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
rules below to a file with suffix <tt>.rules</tt> in the directory
<tt>/etc/audit/rules.d</tt>.
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the rules below to
<tt>/etc/audit/audit.rules</tt> file.
<pre>
-a always,exit -F arch=b32 -S open -F a1&amp;01003 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b32 -S open -F a1&amp;01003 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
</pre>
If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S open -F a1&amp;01003 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b64 -S open -F a1&amp;01003 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
</pre>
      </td>
      <td xml:lang="en-US">
        Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.1.c</td>
      <td>Ensure auditd Rules For Unauthorized Attempts To open Are Ordered Correctly</td>
      <td xml:lang="en-US">
        The audit system should collect detailed unauthorized file
accesses for all users and root.
To correctly identify unsuccessful creation, unsuccessful modification and unsuccessful access
of files via <tt>open</tt> syscall the audit rules collecting these events need to be in certain order.
The more specific rules need to come before the less specific rules. The reason for that is that more
specific rules cover a subset of events covered in the less specific rules, thus, they need to come
before to not be overshadowed by less specific rules, which match a bigger set of events.
Make sure that rules for unsuccessful calls of <tt>open</tt> syscall are in the order shown below.
If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), check the order of
rules below in a file with suffix <tt>.rules</tt> in the directory
<tt>/etc/audit/rules.d</tt>.
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, check the order of rules below in
<tt>/etc/audit/audit.rules</tt> file.
<pre>
-a always,exit -F arch=b32 -S open -F a1&amp;0100 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b32 -S open -F a1&amp;0100 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b32 -S open -F a1&amp;01003 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b32 -S open -F a1&amp;01003 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b32 -S open -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-access
-a always,exit -F arch=b32 -S open -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-access
</pre>
If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S open -F a1&amp;0100 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b64 -S open -F a1&amp;0100 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b64 -S open -F a1&amp;01003 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b64 -S open -F a1&amp;01003 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b64 -S open -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-access
-a always,exit -F arch=b64 -S open -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-access
</pre>
      </td>
      <td xml:lang="en-US">
        The more specific rules cover a subset of events covered by the less specific rules.
By ordering them from more specific to less specific, it is assured that the less specific
rule will not catch events better recorded by the more specific rule.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.2</td>
      <td>Set type of computer node name logging in audit logs</td>
      <td xml:lang="en-US">
        To configure Audit daemon to use a unique identifier
as computer node name in the audit events,
set <tt>name_format</tt> to <tt><abbr title="$var_auditd_name_format"><tt>hostname</tt></abbr></tt>
in <tt>/etc/audit/auditd.conf</tt>.
      </td>
      <td xml:lang="en-US">
        If option <tt>name_format</tt> is left at its default value of
<tt>none</tt>, audit events from different computers may be hard
to distinguish.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.2</td>
      <td>Resolve information before writing to audit logs</td>
      <td xml:lang="en-US">
        To configure Audit daemon to resolve all uid, gid, syscall,
architecture, and socket address information before writing the
events to disk, set <tt>log_format</tt> to <tt>ENRICHED</tt>
in <tt>/etc/audit/auditd.conf</tt>.
      </td>
      <td xml:lang="en-US">
        If option <tt>log_format</tt> isn't set to <tt>ENRICHED</tt>, the
audit records will be stored in a format exactly as the kernel sends them.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.2</td>
      <td>Configure immutable Audit login UIDs</td>
      <td xml:lang="en-US">
        Configure kernel to prevent modification of login UIDs once they are set.
Changing login UIDs while this configuration is enforced requires special capabilities which
are not available to unprivileged users.

The following rules configure audit as described above:
<pre>## Make the loginuid immutable. This prevents tampering with the auid.
--loginuid-immutable    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>
      </td>
      <td xml:lang="en-US">
        If modification of login UIDs is not prevented, they can be changed by unprivileged users and
make auditing complicated or impossible.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.2</td>
      <td>Disable Ctrl-Alt-Del Reboot Activation</td>
      <td xml:lang="en-US">
        By default, <tt>SystemD</tt> will reboot the system if the <tt>Ctrl-Alt-Del</tt>
key sequence is pressed.
<br /><br />
To configure the system to ignore the <tt>Ctrl-Alt-Del</tt> key sequence from the

command line instead of rebooting the system, do either of the following:
<pre>ln -sf /dev/null /etc/systemd/system/ctrl-alt-del.target</pre>
or
<pre>systemctl mask ctrl-alt-del.target</pre>
<br /><br />
Do not simply delete the <tt>/usr/lib/systemd/system/ctrl-alt-del.service</tt> file,
as this file may be restored during future system updates.
      </td>
      <td xml:lang="en-US">
        A locally logged-in user who presses Ctrl-Alt-Del, when at the console,
can reboot the system. If accidentally pressed, as could happen in
the case of mixed OS environment, this can create the risk of short-term
loss of availability of systems due to unintentional reboot.
      </td>
    </tr>
    <tr>
      <td>FAU_GEN.1.2</td>
      <td>Disable Ctrl-Alt-Del Burst Action</td>
      <td xml:lang="en-US">
        By default, <tt>SystemD</tt> will reboot the system if the <tt>Ctrl-Alt-Del</tt>
key sequence is pressed Ctrl-Alt-Delete more than 7 times in 2 seconds.
<br /><br />
To configure the system to ignore the <tt>CtrlAltDelBurstAction</tt>

setting, add or modify the following to <tt>/etc/systemd/system.conf</tt>:
<pre>CtrlAltDelBurstAction=none</pre>
      </td>
      <td xml:lang="en-US">
        A locally logged-in user who presses Ctrl-Alt-Del, when at the console,
can reboot the system. If accidentally pressed, as could happen in
the case of mixed OS environment, this can create the risk of short-term
loss of availability of systems due to unintentional reboot.
      </td>
    </tr>
    <tr>
      <td>FAU_STG.1</td>
      <td>Write Audit Logs to the Disk</td>
      <td xml:lang="en-US">
        To configure Audit daemon to write Audit logs to the disk, set
<tt>write_logs</tt> to <tt>yes</tt> in <tt>/etc/audit/auditd.conf</tt>.
This is the default setting.
      </td>
      <td xml:lang="en-US">
        If <tt>write_logs</tt> isn't set to <tt>yes</tt>, the Audit logs will
not be written to the disk.
      </td>
    </tr>
    <tr>
      <td>FAU_STG.1<br/>FAU_STG.3</td>
      <td>Extend Audit Backlog Limit for the Audit Daemon in zIPL</td>
      <td xml:lang="en-US">
        To improve the kernel capacity to queue all log events, even those which start prior to the audit daemon,
check that all boot entries in <tt>/boot/loader/entries/*.conf</tt> have <tt>audit_backlog_limit=8192</tt>
included in its options.<br />
To ensure that new kernels and boot entries continue to extend the audit log events queue,
add <tt>audit_backlog_limit=8192</tt> to <tt>/etc/kernel/cmdline</tt>.
      </td>
      <td xml:lang="en-US">
        audit_backlog_limit sets the queue length for audit events awaiting transfer
to the audit daemon. Until the audit daemon is up and running, all log messages
are stored in this queue.  If the queue is overrun during boot process, the action
defined by audit failure flag is taken.
      </td>
    </tr>
    <tr>
      <td>FAU_STG.1<br/>FAU_STG.3</td>
      <td>Extend Audit Backlog Limit for the Audit Daemon</td>
      <td xml:lang="en-US">
        To improve the kernel capacity to queue all log events, even those which occurred
prior to the audit daemon, add the argument <tt>audit_backlog_limit=8192</tt> to the default
GRUB 2 command line for the Linux operating system.
To ensure that <tt>audit_backlog_limit=8192</tt> is added as a kernel command line
argument to newly installed kernels, add <tt>audit_backlog_limit=8192</tt> to the
default Grub2 command line for Linux operating systems. Modify the line within
<tt>/etc/default/grub</tt> as shown below:
<pre>GRUB_CMDLINE_LINUX="... audit_backlog_limit=8192 ..."</pre>
Run the following command to update command line for already installed kernels:<pre># grubby --update-kernel=ALL --args="audit_backlog_limit=8192"</pre>
      </td>
      <td xml:lang="en-US">
        audit_backlog_limit sets the queue length for audit events awaiting transfer
to the audit daemon. Until the audit daemon is up and running, all log messages
are stored in this queue.  If the queue is overrun during boot process, the action
defined by audit failure flag is taken.
      </td>
    </tr>
    <tr>
      <td>FCS_CKM.1.1</td>
      <td>SSH client uses strong entropy to seed (Bash-like shells)</td>
      <td xml:lang="en-US">
        To set up SSH client to use entropy from a high-quality source, make sure
that the appropriate shell environment variable is configured. The
<tt>SSH_USE_STRONG_RNG</tt> environment variable determines how many bytes
of entropy to use. Make sure that the file
<tt>/etc/profile.d/cc-ssh-strong-rng.sh</tt> contains line
<pre>export SSH_USE_STRONG_RNG=32</pre>.
      </td>
      <td xml:lang="en-US">
        Some SSH implementations use the openssl library for entropy, which by default, doesn't use high-entropy sources.
Randomness is needed to generate considerably more secure data-encryption keys. Plaintext padding, initialization vectors
in encryption algorithms, and high-quality entropy eliminates the possibility that the output of
the random number generator used by SSH would be known to potential attackers.
      </td>
    </tr>
    <tr>
      <td>FCS_CKM.1.1</td>
      <td>SSH client uses strong entropy to seed (for CSH like shells)</td>
      <td xml:lang="en-US">
        To set up SSH client to use entropy from a high-quality source, make sure
that the appropriate shell environment variable is configured. The
<tt>SSH_USE_STRONG_RNG</tt> environment variable determines how many bytes
of entropy to use. Make sure that the file
<tt>/etc/profile.d/cc-ssh-strong-rng.csh</tt> contains line
<pre>setenv SSH_USE_STRONG_RNG 32</pre>.
      </td>
      <td xml:lang="en-US">
        Some SSH implementations use the openssl library for entropy, which by default, doesn't use high-entropy sources.
Randomness is needed to generate considerably more secure data-encryption keys. Plaintext padding, initialization vectors
in encryption algorithms, and high-quality entropy eliminates the possibility that the output of
the random number generator used by SSH would be known to potential attackers.
      </td>
    </tr>
    <tr>
      <td>FCS_COP.1(1)<br/>FCS_COP.1(2)<br/>FCS_COP.1(3)<br/>FCS_COP.1(4)<br/>FCS_CKM.1<br/>FCS_CKM.2<br/>FCS_TLSC_EXT.1</td>
      <td>Install crypto-policies package</td>
      <td xml:lang="en-US">
        The <code>crypto-policies</code> package can be installed with the following command:
<pre>
$ sudo yum install crypto-policies</pre>
      </td>
      <td xml:lang="en-US">
        Centralized cryptographic policies simplify applying secure ciphers across an operating system and
the applications that run on that operating system. Use of weak or untested encryption algorithms
undermines the purposes of utilizing encryption to protect data.
      </td>
    </tr>
    <tr>
      <td>FCS_COP.1(1)<br/>FCS_COP.1(2)<br/>FCS_COP.1(3)<br/>FCS_COP.1(4)<br/>FCS_CKM.1<br/>FCS_CKM.2<br/>FCS_TLSC_EXT.1<br/>FCS_RBG_EXT.1</td>
      <td>Enable FIPS Mode</td>
      <td xml:lang="en-US">
        
To enable FIPS mode, run the following command:
<pre>fips-mode-setup --enable</pre>
<br />
The <tt>fips-mode-setup</tt> command will configure the system in
FIPS mode by automatically configuring the following:
<ul>
<li>Setting the kernel FIPS mode flag (<tt>/proc/sys/crypto/fips_enabled</tt>) to <tt>1</tt></li>
<li>Creating <tt>/etc/system-fips</tt></li>
<li>Setting the system crypto policy in <tt>/etc/crypto-policies/config</tt> to <tt><abbr title="$var_system_crypto_policy"><tt>DEFAULT</tt></abbr></tt></li>
<li>Loading the Dracut <tt>fips</tt> module</li>
</ul>
      </td>
      <td xml:lang="en-US">
        Use of weak or untested encryption algorithms undermines the purposes of utilizing encryption to
protect data. The operating system must implement cryptographic modules adhering to the higher
standards approved by the federal government since this provides assurance they have been tested
and validated.
      </td>
    </tr>
    <tr>
      <td>FCS_COP.1(1)<br/>FCS_COP.1(2)<br/>FCS_COP.1(3)<br/>FCS_COP.1(4)<br/>FCS_CKM.1<br/>FCS_CKM.2<br/>FCS_TLSC_EXT.1</td>
      <td>Configure System Cryptography Policy</td>
      <td xml:lang="en-US">
        To configure the system cryptography policy to use ciphers only from the <tt><abbr title="$var_system_crypto_policy"><tt>DEFAULT</tt></abbr></tt>
policy, run the following command:
<pre>$ sudo update-crypto-policies --set <abbr title="$var_system_crypto_policy"><tt>DEFAULT</tt></abbr></pre>
The rule checks if settings for selected crypto policy are configured as expected. Configuration files in the <tt>/etc/crypto-policies/back-ends</tt> are either symlinks to correct files provided by Crypto-policies package or they are regular files in case crypto policy customizations are applied.
Crypto policies may be customized by crypto policy modules, in which case it is delimited from the base policy using a colon.
      </td>
      <td xml:lang="en-US">
        Centralized cryptographic policies simplify applying secure ciphers across an operating system and
the applications that run on that operating system. Use of weak or untested encryption algorithms
undermines the purposes of utilizing encryption to protect data.
      </td>
    </tr>
    <tr>
      <td>FCS_IPSEC_EXT.1.4<br/>FCS_IPSEC_EXT.1.6</td>
      <td>Configure Libreswan to use System Crypto Policy</td>
      <td xml:lang="en-US">
        Crypto Policies provide a centralized control over crypto algorithms usage of many packages.
Libreswan is supported by system crypto policy, but the Libreswan configuration may be
set up to ignore it.

To check that Crypto Policies settings are configured correctly, ensure that the <tt>/etc/ipsec.conf</tt>
includes the appropriate configuration file.
In <tt>/etc/ipsec.conf</tt>, make sure that the following line
is not commented out or superseded by later includes:
<tt>include /etc/crypto-policies/back-ends/libreswan.config</tt>
      </td>
      <td xml:lang="en-US">
        Overriding the system crypto policy makes the behavior of the Libreswan
service violate expectations, and makes system configuration more
fragmented.
      </td>
    </tr>
    <tr>
      <td>FCS_RBG_EXT.1</td>
      <td>Enable Dracut FIPS Module</td>
      <td xml:lang="en-US">
        To enable FIPS mode, run the following command:
<pre>fips-mode-setup --enable</pre>
To enable FIPS, the system requires that the <tt>fips</tt> module is added in <tt>dracut</tt> configuration.
Check if <tt>/etc/dracut.conf.d/40-fips.conf</tt> contain <tt>add_dracutmodules+=" fips "</tt>
      </td>
      <td xml:lang="en-US">
        Use of weak or untested encryption algorithms undermines the purposes of utilizing encryption to
protect data. The operating system must implement cryptographic modules adhering to the higher
standards approved by the federal government since this provides assurance they have been tested
and validated.
      </td>
    </tr>
    <tr>
      <td>FCS_RBG_EXT.1</td>
      <td>Enable the Hardware RNG Entropy Gatherer Service</td>
      <td xml:lang="en-US">
        The Hardware RNG Entropy Gatherer service should be enabled.

The <code>rngd</code> service can be enabled with the following command:
<pre>$ sudo systemctl enable rngd.service</pre>
      </td>
      <td xml:lang="en-US">
        The <tt>rngd</tt> service
feeds random data from hardware device to kernel random device.
      </td>
    </tr>
    <tr>
      <td>FCS_RBG_EXT.1.1</td>
      <td>Configure kernel to trust the CPU random number generator</td>
      <td xml:lang="en-US">
        There exist two ways how to ensure that the Linux kernel trusts the CPU
hardware random number generator. If the option is configured during kernel
compilation, e.g. the option <tt>CONFIG_RANDOM_TRUST_CPU</tt> is set to
<tt>Y</tt>, make sure that it is not overridden with the boot parameter.
There must not exist the boot parameter <tt>random.trust_cpu=off</tt>. If
the option is not compiled in, make sure that <tt>random.trust_cpu=on</tt>
is configured as a boot parameter.
To ensure that <tt>random.trust_cpu=on</tt> is added as a kernel command line
argument to newly installed kernels, add <tt>random.trust_cpu=on</tt> to the
default Grub2 command line for Linux operating systems. Modify the line within
<tt>/etc/default/grub</tt> as shown below:
<pre>GRUB_CMDLINE_LINUX="... random.trust_cpu=on ..."</pre>
Run the following command to update command line for already installed kernels:<pre># grubby --update-kernel=ALL --args="random.trust_cpu=on"</pre>
      </td>
      <td xml:lang="en-US">
        The Linux kernel offers an option which signifies if the kernel should trust
data provided by CPU hardware random number generator. Hardware random
number generators can provide random data very quickly and are used to generate random cryptographic keys. They can
be useful during boot time when other means of getting random data can be
slow because there is not yet enough entropy in the system.
      </td>
    </tr>
    <tr>
      <td>FCS_RBG_EXT.1.2</td>
      <td>OpenSSL uses strong entropy source</td>
      <td xml:lang="en-US">
        By default, OpenSSL doesn't always use a SP800-90A compliant random number generator.
A way to configure OpenSSL to always use a strong source is to setup a wrapper that
defines a shell function that shadows the actual <tt>openssl</tt> binary,
and that ensures that the <tt>-rand /dev/random</tt> option is added to every <tt>openssl</tt> invocation.

To do so, place the following shell snippet exactly as-is to <tt>/etc/profile.d/openssl-rand.sh</tt>:
<pre>
# provide a default -rand /dev/random option to openssl commands that
# support it

# written inefficiently for maximum shell compatibility
openssl()
(
  openssl_bin=/usr/bin/openssl

  case "$*" in
    # if user specified -rand, honor it
    *\ -rand\ *|*\ -help*) exec $openssl_bin "$@" ;;
  esac

  cmds=`$openssl_bin list -digest-commands -cipher-commands | tr '\n' ' '`
  for i in `$openssl_bin list -commands`; do
    if $openssl_bin list -options "$i" | grep -q '^rand '; then
      cmds=" $i $cmds"
    fi
  done

  case "$cmds" in
    *\ "$1"\ *)
      cmd="$1"; shift
      exec $openssl_bin "$cmd" -rand /dev/random "$@" ;;
  esac

  exec $openssl_bin "$@"
)
</pre>
      </td>
      <td xml:lang="en-US">
        This rule ensures that <tt>openssl</tt> invocations always uses SP800-90A compliant random number generator as a default behavior.
      </td>
    </tr>
    <tr>
      <td>FCS_RBG_EXT.1.2</td>
      <td>SSH server uses strong entropy to seed</td>
      <td xml:lang="en-US">
        To set up SSH server to use entropy from a high-quality source, edit the <tt>/etc/sysconfig/sshd</tt> file.
The <tt>SSH_USE_STRONG_RNG</tt> configuration value determines how many bytes of entropy to use, so
make sure that the file contains line
<pre>SSH_USE_STRONG_RNG=32</pre>
      </td>
      <td xml:lang="en-US">
        SSH implementation in Red Hat Enterprise Linux 7 uses the openssl library, which doesn't use
high-entropy sources by default. Randomness is needed to generate data-encryption keys, and as
plaintext padding and initialization vectors in encryption algorithms, and high-quality
entropy elliminates the possibility that the output of the random number generator used by SSH
would be known to potential attackers.
      </td>
    </tr>
    <tr>
      <td>FCS_SSHC_EXT.1</td>
      <td>Harden SSH client Crypto Policy</td>
      <td xml:lang="en-US">
        Crypto Policies are means of enforcing certain cryptographic settings for selected applications including OpenSSH client.
To override the system wide crypto policy for Openssh client, place a file in the <tt>/etc/ssh/ssh_config.d/</tt> so that it is loaded before the <tt>05-redhat.conf</tt>. In this case it is file named <tt>02-ospp.conf</tt> containing parameters which need to be changed with respect to the crypto policy.
This rule checks if the file exists and if it contains required parameters and values which modify the Crypto Policy.
During the parsing process, as soon as Openssh client parses some configuration option and its value, it remembers it and ignores any subsequent overrides. The customization mechanism provided by crypto policies appends eventual customizations at the end of the system wide crypto policy. Therefore, if the crypto policy customization overrides some parameter which is already configured in the system wide crypto policy, the SSH client will not honor that customized parameter.
      </td>
      <td xml:lang="en-US">
        The Common Criteria requirements specify how certain parameters for OpenSSH Client are configured. Particular parameters are RekeyLimit, GSSAPIAuthentication, Ciphers, PubkeyAcceptedKeyTypes, MACs and KexAlgorithms. Currently particular requirements specified by CC are stricter compared to any existing Crypto Policy.
      </td>
    </tr>
    <tr>
      <td>FCS_SSHS_EXT.1</td>
      <td>Harden SSHD Crypto Policy</td>
      <td xml:lang="en-US">
        Crypto Policies are means of enforcing certain cryptographic settings for selected applications including OpenSSH server.
The SSHD service is by default configured to modify its configuration based on currently configured Crypto-Policy. However, in certain cases it might be needed to override the Crypto Policy specific to OpenSSH Server and leave rest of the Crypto Policy intact.
This can be done by dropping a file named <tt>opensshserver-xxx.config</tt>, replacing <tt>xxx</tt> with arbitrary identifier, into <tt>/etc/crypto-policies/local.d</tt>. This has to be followed by running <tt>update-crypto-policies</tt> so that changes are applied.
Changes are propagated into <tt>/etc/crypto-policies/back-ends/opensshserver.config</tt>. This rule checks if this file contains predefined <tt>CRYPTO_POLICY</tt> environment variable configured with predefined value.
      </td>
      <td xml:lang="en-US">
        The Common Criteria requirements specify that certain parameters for OpenSSH Server are configured e.g. supported ciphers, accepted host key algorithms, public key types, key exchange algorithms, HMACs and GSSAPI key exchange is disabled. Currently particular requirements specified by CC are stricter compared to any existing Crypto Policy.
      </td>
    </tr>
    <tr>
      <td>FCS_SSH_EXT.1<br/>FCS_SSHS_EXT.1<br/>FCS_SSHC_EXT.1</td>
      <td>Configure SSH to use System Crypto Policy</td>
      <td xml:lang="en-US">
        Crypto Policies provide a centralized control over crypto algorithms usage of many packages.
SSH is supported by crypto policy, but the SSH configuration may be
set up to ignore it.
To check that Crypto Policies settings are configured correctly, ensure that
the <tt>CRYPTO_POLICY</tt> variable is either commented or not set at all
in the <tt>/etc/sysconfig/sshd</tt>.
      </td>
      <td xml:lang="en-US">
        Overriding the system crypto policy makes the behavior of the SSH service violate expectations,
and makes system configuration more fragmented.
      </td>
    </tr>
    <tr>
      <td>FCS_SSH_EXT.1.8</td>
      <td>Configure session renegotiation for SSH client</td>
      <td xml:lang="en-US">
        The <tt>RekeyLimit</tt> parameter specifies how often
the session key is renegotiated, both in terms of
amount of data that may be transmitted and the time
elapsed. To decrease the default limits, put line
<tt>RekeyLimit <abbr title="$var_ssh_client_rekey_limit_size"><tt>512M</tt></abbr> <abbr title="$var_ssh_client_rekey_limit_time"><tt>1h</tt></abbr></tt> to file <tt>/etc/ssh/ssh_config.d/02-rekey-limit.conf</tt>.
Make sure that there is no other <tt>RekeyLimit</tt> configuration preceding
the <tt>include</tt> directive in the main config file
<tt>/etc/ssh/ssh_config</tt>. Check also other files in
<tt>/etc/ssh/ssh_config.d</tt> directory. Files are processed according to
lexicographical order of file names. Make sure that there is no file
processed before <tt>02-rekey-limit.conf</tt> containing definition of
<tt>RekeyLimit</tt>.
      </td>
      <td xml:lang="en-US">
        By decreasing the limit based on the amount of data and enabling
time-based limit, effects of potential attacks against
encryption keys are limited.
      </td>
    </tr>
    <tr>
      <td>FCS_SSH_EXT.1.8</td>
      <td>Force frequent session key renegotiation</td>
      <td xml:lang="en-US">
        The <tt>RekeyLimit</tt> parameter specifies how often
the session key of the is renegotiated, both in terms of
amount of data that may be transmitted and the time
elapsed.<br/>
To decrease the default limits, add or correct the following line in


<tt>/etc/ssh/sshd_config</tt>:

<pre>RekeyLimit <abbr title="$var_rekey_limit_size"><tt>512M</tt></abbr> <abbr title="$var_rekey_limit_time"><tt>1h</tt></abbr></pre>
      </td>
      <td xml:lang="en-US">
        By decreasing the limit based on the amount of data and enabling
time-based limit, effects of potential attacks against
encryption keys are limited.
      </td>
    </tr>
    <tr>
      <td>FCS_TLSC_EXT.1<br/>FTP_ITC_EXT.1.1<br/>FIA_X509_EXT.1.1<br/>FMT_SMF_EXT.1.1</td>
      <td>Configure TLS for rsyslog remote logging</td>
      <td xml:lang="en-US">
        Configure <tt>rsyslog</tt> to use Transport Layer
Security (TLS) support for logging to remote server
for the Forwarding Output Module in <tt>/etc/rsyslog.conf</tt>
using action. You can use the following command:
<pre>echo 'action(type="omfwd" protocol="tcp" Target="&lt;remote system>" port="6514"
    StreamDriver="gtls" StreamDriverMode="1" StreamDriverAuthMode="x509/name" streamdriver.CheckExtendedKeyPurpose="on")' >> /etc/rsyslog.conf
</pre>
Replace the <tt>&lt;remote system></tt> in the above command with an IP address or a host name of the remote logging server.
      </td>
      <td xml:lang="en-US">
        For protection of data being logged, the connection to the
remote logging server needs to be authenticated and encrypted.
      </td>
    </tr>
    <tr>
      <td>FCS_TLSC_EXT.1</td>
      <td>Configure CA certificate for rsyslog remote logging</td>
      <td xml:lang="en-US">
        Configure CA certificate for <tt>rsyslog</tt> logging
to remote server using Transport Layer Security (TLS)
using correct path for the <tt>DefaultNetstreamDriverCAFile</tt>
global option in <tt>/etc/rsyslog.conf</tt>, for example with the following command:
<pre>echo 'global(DefaultNetstreamDriverCAFile="/etc/pki/tls/cert.pem")' >> /etc/rsyslog.conf</pre>
Replace the <tt>/etc/pki/tls/cert.pem</tt> in the above command with the path to the file with CA certificate generated for the purpose of remote logging.
      </td>
      <td xml:lang="en-US">
        The CA certificate needs to be set or <tt>rsyslog.service</tt>
fails to start with
<pre>error: ca certificate is not set, cannot continue</pre>
      </td>
    </tr>
    <tr>
      <td>FCS_TLSC_EXT.1.1</td>
      <td>Harden OpenSSL Crypto Policy</td>
      <td xml:lang="en-US">
        Crypto Policies are means of enforcing certain cryptographic settings for
selected applications including OpenSSL. OpenSSL is by default configured to
modify its configuration based on currently configured Crypto Policy.
However, in certain cases it might be needed to override the Crypto Policy
specific to OpenSSL and leave rest of the Crypto Policy intact. This can
be done by dropping a file named <tt>opensslcnf-xxx.config</tt>, replacing
<tt>xxx</tt> with arbitrary identifier, into
<tt>/etc/crypto-policies/local.d</tt>. This has to be followed by running
<tt>update-crypto-policies</tt> so that changes are applied. Changes are
propagated into <tt>/etc/crypto-policies/back-ends/opensslcnf.config</tt>.
This rule checks if this file contains predefined <tt>Ciphersuites</tt>
variable configured with predefined value.
      </td>
      <td xml:lang="en-US">
        The Common Criteria requirements specify that certain parameters for OpenSSL
are configured e.g. cipher suites. Currently particular requirements
specified by CC are stricter compared to any existing Crypto Policy.
      </td>
    </tr>
    <tr>
      <td>FIA_AFL.1</td>
      <td>Set Interval For Counting Failed Password Attempts</td>
      <td xml:lang="en-US">
        Utilizing <tt>pam_faillock.so</tt>, the <tt>fail_interval</tt> directive configures the system
to lock out an account after a number of incorrect login attempts within a specified time
period.

Ensure that pam_faillock.so module entries in
<tt>/etc/pam.d/password-auth</tt> and <tt>/etc/pam.d/system-auth</tt> are
followed by the assignment
<tt>fail_interval=&lt;interval-in-seconds&gt;</tt> where
<tt>interval-in-seconds</tt> is <tt><abbr title="$var_accounts_passwords_pam_faillock_fail_interval"><tt>900</tt></abbr></tt> or greater.


In order to avoid errors when manually editing these files, it is
recommended to use the appropriate tools, such as <tt>authselect</tt> or <tt>authconfig</tt>,
depending on the OS version.
      </td>
      <td xml:lang="en-US">
        By limiting the number of failed logon attempts the risk of unauthorized system
access via user password guessing, otherwise known as brute-forcing, is reduced.
Limits are imposed by locking the account.
      </td>
    </tr>
    <tr>
      <td>FIA_AFL.1</td>
      <td>Set Lockout Time for Failed Password Attempts</td>
      <td xml:lang="en-US">
        This rule configures the system to lock out accounts during a specified time period after a
number of incorrect login attempts using <tt>pam_faillock.so</tt>.


Ensure that pam_faillock.so module entries in
<tt>/etc/pam.d/password-auth</tt> and <tt>/etc/pam.d/system-auth</tt> are
followed by the assignment
<tt>unlock_time=&lt;interval-in-seconds&gt;</tt> where
<tt>interval-in-seconds</tt> is <tt><abbr title="$var_accounts_passwords_pam_faillock_unlock_time"><tt>0</tt></abbr></tt> or greater.


pam_faillock.so module requires multiple entries in pam files. These entries must be carefully
defined to work as expected. In order to avoid any errors when manually editing these files,
it is recommended to use the appropriate tools, such as <tt>authselect</tt> or <tt>authconfig</tt>,
depending on the OS version.

If <tt>unlock_time</tt> is set to <tt>0</tt>, manual intervention by an administrator is required
to unlock a user. This should be done using the <tt>faillock</tt> tool.
      </td>
      <td xml:lang="en-US">
        By limiting the number of failed logon attempts the risk of unauthorized system
access via user password guessing, otherwise known as brute-forcing, is reduced.
Limits are imposed by locking the account.
      </td>
    </tr>
    <tr>
      <td>FIA_AFL.1</td>
      <td>Lock Accounts After Failed Password Attempts</td>
      <td xml:lang="en-US">
        This rule configures the system to lock out accounts after a number of incorrect login attempts
using <tt>pam_faillock.so</tt>.
pam_faillock.so module requires multiple entries in pam files. These entries must be carefully
defined to work as expected.

Ensure that pam_faillock.so module entries in
<tt>/etc/pam.d/password-auth</tt> and <tt>/etc/pam.d/system-auth</tt> are
followed by the assignment <tt>deny=&lt;count&gt;</tt> where count should be less than or equal to
<abbr title="$var_accounts_passwords_pam_faillock_deny"><tt>3</tt></abbr> and greater than 0.


In order to avoid errors when manually editing these files, it is
recommended to use the appropriate tools, such as <tt>authselect</tt> or <tt>authconfig</tt>,
depending on the OS version.
      </td>
      <td xml:lang="en-US">
        By limiting the number of failed logon attempts, the risk of unauthorized system access via
user password guessing, also known as brute-forcing, is reduced. Limits are imposed by locking
the account.
      </td>
    </tr>
    <tr>
      <td>FIA_UAU.1</td>
      <td>Disable SSH Support for User Known Hosts</td>
      <td xml:lang="en-US">
        SSH can allow system users to connect to systems if a cache of the remote
systems public keys is available.  This should be disabled.
<br /><br />
To ensure this behavior is disabled, add or correct the following line in


<tt>/etc/ssh/sshd_config</tt>:

<pre>IgnoreUserKnownHosts yes</pre>
      </td>
      <td xml:lang="en-US">
        Configuring this setting for the SSH daemon provides additional
assurance that remote login via SSH will require a password, even
in the event of misconfiguration elsewhere.
      </td>
    </tr>
    <tr>
      <td>FIA_UAU.1</td>
      <td>Verify that Interactive Boot is Disabled</td>
      <td xml:lang="en-US">
        Red Hat Enterprise Linux 7 systems support an "interactive boot" option that can
be used to prevent services from being started. On a Red Hat Enterprise Linux 7
system, interactive boot can be enabled by providing a <tt>1</tt>,
<tt>yes</tt>, <tt>true</tt>, or <tt>on</tt> value to the
<tt>systemd.confirm_spawn</tt> kernel argument.
      </td>
      <td xml:lang="en-US">
        Using interactive boot, the console user could disable auditing, firewalls,
or other services, weakening system security.
      </td>
    </tr>
    <tr>
      <td>FIA_UAU.1</td>
      <td>Require Authentication for Single User Mode</td>
      <td xml:lang="en-US">
        Single-user mode is intended as a system recovery
method, providing a single user root access to the system by
providing a boot option at startup.
<br /><br />
By default, single-user mode is protected by requiring a password and is set
in <tt>/usr/lib/systemd/system/rescue.service</tt>.
      </td>
      <td xml:lang="en-US">
        This prevents attackers with physical access from trivially bypassing security
on the machine and gaining root access. Such accesses are further prevented
by configuring the bootloader password.
      </td>
    </tr>
    <tr>
      <td>FIA_UAU.1</td>
      <td>Set the Boot Loader Admin Username to a Non-Default Value</td>
      <td xml:lang="en-US">
        The grub2 boot loader should have a superuser account and password
protection enabled to protect boot-time settings.
<br /><br />
To maximize the protection, select a password-protected superuser account with unique name, and modify the
<tt>/etc/grub.d/01_users</tt> configuration file to reflect the account name change.
<br /><br />
Do not to use common administrator account names like root,
admin, or administrator for the grub2 superuser account.
<br /><br />
Change the superuser to a different username (The default is 'root').
<pre>$ sed -i 's/\(set superusers=\).*/\1"&lt;unique user ID&gt;"/g' /etc/grub.d/01_users</pre>
<br /><br />
Once the superuser account has been added,
update the
<tt>grub.cfg</tt> file by running:
<pre>grubby --update-kernel=ALL</pre>
      </td>
      <td xml:lang="en-US">
        Having a non-default grub superuser username makes password-guessing attacks less effective.
      </td>
    </tr>
    <tr>
      <td>FIA_UAU.1</td>
      <td>Set the UEFI Boot Loader Password</td>
      <td xml:lang="en-US">
        The grub2 boot loader should have a superuser account and password
protection enabled to protect boot-time settings.
<br /><br />
Since plaintext passwords are a security risk, generate a hash for the password
by running the following command:

<pre># grub2-setpassword</pre>

When prompted, enter the password that was selected.
<br /><br />
      </td>
      <td xml:lang="en-US">
        Password protection on the boot loader configuration ensures
users with physical access cannot trivially alter
important bootloader settings. These include which kernel to use,
and whether to enter single-user mode.
      </td>
    </tr>
    <tr>
      <td>FIA_UAU.1</td>
      <td>Require Authentication for Emergency Systemd Target</td>
      <td xml:lang="en-US">
        Emergency mode is intended as a system recovery
method, providing a single user root access to the system
during a failed boot sequence.
<br /><br />
By default, Emergency mode is protected by requiring a password and is set
in <tt>/usr/lib/systemd/system/emergency.service</tt>.
      </td>
      <td xml:lang="en-US">
        This prevents attackers with physical access from trivially bypassing security
on the machine and gaining root access. Such accesses are further prevented
by configuring the bootloader password.
      </td>
    </tr>
    <tr>
      <td>FIA_UAU.1</td>
      <td>Disable GDM Guest Login</td>
      <td xml:lang="en-US">
        The GNOME Display Manager (GDM) can allow users to login without credentials
which can be useful for public kiosk scenarios. Allowing users to login without credentials
or "guest" account access has inherent security risks and should be disabled. To do disable
timed logins or guest account access, set the <tt>TimedLoginEnable</tt> to <tt>false</tt> in
the <tt>[daemon]</tt> section in <tt>/etc/gdm/custom.conf</tt>. For example:
<pre>[daemon]
TimedLoginEnable=false</pre>
      </td>
      <td xml:lang="en-US">
        Failure to restrict system access to authenticated users negatively impacts operating
system security.
      </td>
    </tr>
    <tr>
      <td>FIA_UAU.1</td>
      <td>Disable debug-shell SystemD Service</td>
      <td xml:lang="en-US">
        SystemD's <tt>debug-shell</tt> service is intended to
diagnose SystemD related boot issues with various <tt>systemctl</tt>
commands. Once enabled and following a system reboot, the root shell
will be available on <tt>tty9</tt> which is access by pressing
<tt>CTRL-ALT-F9</tt>. The <tt>debug-shell</tt> service should only be used
for SystemD related issues and should otherwise be disabled.
<br /><br />
By default, the <tt>debug-shell</tt> SystemD service is already disabled.

The <code>debug-shell</code> service can be disabled with the following command:
<pre>$ sudo systemctl mask --now debug-shell.service</pre>
      </td>
      <td xml:lang="en-US">
        This prevents attackers with physical access from trivially bypassing security
on the machine through valid troubleshooting configurations and gaining root
access when the system is rebooted.
      </td>
    </tr>
    <tr>
      <td>FIA_UAU.1</td>
      <td>Set Boot Loader Password in grub2</td>
      <td xml:lang="en-US">
        The grub2 boot loader should have a superuser account and password
protection enabled to protect boot-time settings.
<br /><br />
Since plaintext passwords are a security risk, generate a hash for the password
by running the following command:

<pre># grub2-setpassword</pre>

When prompted, enter the password that was selected.
<br /><br />
      </td>
      <td xml:lang="en-US">
        Password protection on the boot loader configuration ensures
users with physical access cannot trivially alter
important bootloader settings. These include which kernel to use,
and whether to enter single-user mode.
      </td>
    </tr>
    <tr>
      <td>FIA_UAU.1</td>
      <td>Verify that Interactive Boot is Disabled</td>
      <td xml:lang="en-US">
        Red Hat Enterprise Linux 7 systems support an "interactive boot" option that can
be used to prevent services from being started. On a Red Hat Enterprise Linux 7
system, interactive boot can be enabled by providing a <tt>1</tt>,
<tt>yes</tt>, <tt>true</tt>, or <tt>on</tt> value to the
<tt>systemd.confirm_spawn</tt> kernel argument in <tt>/etc/default/grub</tt>.
Remove any instance of <pre>systemd.confirm_spawn=(1|yes|true|on)</pre> from
the kernel arguments in that file to disable interactive boot.
Recovery booting must also be disabled. Confirm that
<tt>GRUB_DISABLE_RECOVERY=true</tt> is set in  <tt>/etc/default/grub</tt>.
It is also required to change the runtime configuration, run:

<pre>/sbin/grubby --update-kernel=ALL --remove-args="systemd.confirm_spawn"</pre>

<pre>grub2-mkconfig -o /boot/grub2/grub.cfg</pre>
      </td>
      <td xml:lang="en-US">
        Using interactive or recovery boot, the console user could disable auditing, firewalls,
or other services, weakening system security.
      </td>
    </tr>
    <tr>
      <td>FIA_UAU.1</td>
      <td>Prevent Login to Accounts With Empty Password</td>
      <td xml:lang="en-US">
        If an account is configured for password authentication
but does not have an assigned password, it may be possible to log
into the account without authentication. Remove any instances of the
<tt>nullok</tt> in

<tt>/etc/pam.d/system-auth</tt> and
<tt>/etc/pam.d/password-auth</tt>

to prevent logins with empty passwords.
      </td>
      <td xml:lang="en-US">
        If an account has an empty password, anyone could log in and
run commands with the privileges of that account. Accounts with
empty passwords should never be used in operational environments.
      </td>
    </tr>
    <tr>
      <td>FIA_UAU.1</td>
      <td>Ensure debug-shell service is not enabled in zIPL</td>
      <td xml:lang="en-US">
        systemd's <tt>debug-shell</tt> service is intended to
diagnose systemd related boot issues with various <tt>systemctl</tt>
commands. Once enabled and following a system reboot, the root shell
will be available on <tt>tty9</tt> which is access by pressing
<tt>CTRL-ALT-F9</tt>. The <tt>debug-shell</tt> service should only be used
for systemd related issues and should otherwise be disabled.
<br /><br />
By default, the <tt>debug-shell</tt> systemd service is already disabled.

Ensure the debug-shell is not enabled by the <tt>systemd.debug-shel=1</tt>
boot paramenter option.

Check that not boot entries in <tt>/boot/loader/entries/*.conf</tt> have
<tt>systemd.debug-shell=1</tt> included in its options.<br />
To ensure that new kernels and boot entries don't enable the debug-shell, check
that <tt>systemd.debug-shell=1</tt> is not present in <tt>/etc/kernel/cmdline</tt>.
      </td>
      <td xml:lang="en-US">
        This prevents attackers with physical access from trivially bypassing security
on the machine through valid troubleshooting configurations and gaining root
access when the system is rebooted.
      </td>
    </tr>
    <tr>
      <td>FIA_UAU.1</td>
      <td>Disable SSH Access via Empty Passwords</td>
      <td xml:lang="en-US">
        Disallow SSH login with empty passwords.
The default SSH configuration disables logins with empty passwords. The appropriate
configuration is used if no value is set for <tt>PermitEmptyPasswords</tt>.
<br />
To explicitly disallow SSH login from accounts with empty passwords,
add or correct the following line in


<tt>/etc/ssh/sshd_config</tt>:

<br />
<pre>PermitEmptyPasswords no</pre>
Any accounts with empty passwords should be disabled immediately, and PAM configuration
should prevent users from being able to assign themselves empty passwords.
      </td>
      <td xml:lang="en-US">
        Configuring this setting for the SSH daemon provides additional assurance
that remote login via SSH will require a password, even in the event of
misconfiguration elsewhere.
      </td>
    </tr>
    <tr>
      <td>FIA_UAU.1</td>
      <td>Disable SSH Support for .rhosts Files</td>
      <td xml:lang="en-US">
        SSH can emulate the behavior of the obsolete rsh
command in allowing users to enable insecure access to their
accounts via <tt>.rhosts</tt> files.
<br />
The default SSH configuration disables support for <tt>.rhosts</tt>. The appropriate
configuration is used if no value is set for <tt>IgnoreRhosts</tt>.
<br/>
To explicitly disable support for .rhosts files, add or correct the following line in


<tt>/etc/ssh/sshd_config</tt>:

<pre>IgnoreRhosts yes</pre>
      </td>
      <td xml:lang="en-US">
        SSH trust relationships mean a compromise on one host
can allow an attacker to move trivially to other hosts.
      </td>
    </tr>
    <tr>
      <td>FIA_UAU.1</td>
      <td>Disable SSH Support for Rhosts RSA Authentication</td>
      <td xml:lang="en-US">
        SSH can allow authentication through the obsolete rsh
command through the use of the authenticating user's SSH keys. This should be disabled.
<br /><br />
To ensure this behavior is disabled, add or correct the
following line in <tt>/etc/ssh/sshd_config</tt>:
<pre>RhostsRSAAuthentication no</pre>
      </td>
      <td xml:lang="en-US">
        Configuring this setting for the SSH daemon provides additional
assurance that remote login via SSH will require a password, even
in the event of misconfiguration elsewhere.
      </td>
    </tr>
    <tr>
      <td>FIA_UAU.1<br/>FIA_AFL.1</td>
      <td>Enable authselect</td>
      <td xml:lang="en-US">
        Configure user authentication setup to use the <tt>authselect</tt> tool.
If authselect profile is selected, the rule will enable the <abbr title="$var_authselect_profile"><tt>minimal</tt></abbr> profile.
      </td>
      <td xml:lang="en-US">
        Authselect is a successor to authconfig.
It is a tool to select system authentication and identity sources from a list of supported
profiles instead of letting the administrator manually build the PAM stack.

That way, it avoids potential breakage of configuration, as it ships several tested profiles
that are well tested and supported to solve different use-cases.
      </td>
    </tr>
    <tr>
      <td>FIA_UAU.1</td>
      <td>Ensure debug-shell service is not enabled during boot</td>
      <td xml:lang="en-US">
        systemd's <tt>debug-shell</tt> service is intended to
diagnose systemd related boot issues with various <tt>systemctl</tt>
commands. Once enabled and following a system reboot, the root shell
will be available on <tt>tty9</tt> which is access by pressing
<tt>CTRL-ALT-F9</tt>. The <tt>debug-shell</tt> service should only be used
for systemd related issues and should otherwise be disabled.
<br /><br />
By default, the <tt>debug-shell</tt> systemd service is already disabled.

Ensure the debug-shell is not enabled by the <tt>systemd.debug-shel=1</tt>
boot paramenter option.

Check that the line <pre>GRUB_CMDLINE_LINUX="..."</pre> within <tt>/etc/default/grub</tt>
doesn't contain the argument <tt>systemd.debug-shell=1</tt>.
Run the following command to update command line for already installed kernels:
<pre># grubby --update-kernel=ALL --remove-args="systemd.debug-shell"</pre>
      </td>
      <td xml:lang="en-US">
        This prevents attackers with physical access from trivially bypassing security
on the machine through valid troubleshooting configurations and gaining root
access when the system is rebooted.
      </td>
    </tr>
    <tr>
      <td>FIA_UAU.1</td>
      <td>Disable GDM Automatic Login</td>
      <td xml:lang="en-US">
        The GNOME Display Manager (GDM) can allow users to automatically login without
user interaction or credentials. User should always be required to authenticate themselves
to the system that they are authorized to use. To disable user ability to automatically
login to the system, set the <tt>AutomaticLoginEnable</tt> to <tt>false</tt> in the
<tt>[daemon]</tt> section in <tt>/etc/gdm/custom.conf</tt>. For example:
<pre>[daemon]
AutomaticLoginEnable=false</pre>
      </td>
      <td xml:lang="en-US">
        Failure to restrict system access to authenticated users negatively impacts operating
system security.
      </td>
    </tr>
    <tr>
      <td>FIA_UAU.1</td>
      <td>Disable Host-Based Authentication</td>
      <td xml:lang="en-US">
        SSH's cryptographic host-based authentication is
more secure than <tt>.rhosts</tt> authentication. However, it is
not recommended that hosts unilaterally trust one another, even
within an organization.
<br />
The default SSH configuration disables host-based authentication. The appropriate
configuration is used if no value is set for <tt>HostbasedAuthentication</tt>.
<br />
To explicitly disable host-based authentication, add or correct the
following line in


<tt>/etc/ssh/sshd_config</tt>:

<pre>HostbasedAuthentication no</pre>
      </td>
      <td xml:lang="en-US">
        SSH trust relationships mean a compromise on one host
can allow an attacker to move trivially to other hosts.
      </td>
    </tr>
    <tr>
      <td>FIA_UAU.1</td>
      <td>Disable Recovery Booting</td>
      <td xml:lang="en-US">
        Red Hat Enterprise Linux 7 systems support an "recovery boot" option that can be used
to prevent services from being started. The <tt>GRUB_DISABLE_RECOVERY</tt>
configuration option in <tt>/etc/default/grub</tt> should be set to
<tt>true</tt> to disable the generation of recovery mode menu entries. It is
also required to change the runtime configuration, run:
<pre>$ sudo grubby --update-kernel=ALL</pre>
      </td>
      <td xml:lang="en-US">
        Using recovery boot, the console user could disable auditing, firewalls,
or other services, weakening system security.
      </td>
    </tr>
    <tr>
      <td>FIA_UAU.1</td>
      <td>Set the UEFI Boot Loader Admin Username to a Non-Default Value</td>
      <td xml:lang="en-US">
        The grub2 boot loader should have a superuser account and password
protection enabled to protect boot-time settings.
<br /><br />
To maximize the protection, select a password-protected superuser account with unique name, and modify the
<tt>/etc/grub.d/01_users</tt> configuration file to reflect the account name change.
<br /><br />
It is highly suggested not to use common administrator account names like root,
admin, or administrator for the grub2 superuser account.
<br /><br />
Change the superuser to a different username (The default is 'root').
<pre>$ sed -i 's/\(set superusers=\).*/\1"&lt;unique user ID&gt;"/g' /etc/grub.d/01_users</pre>
<br /><br />
Once the superuser account has been added,
update the
<tt>grub.cfg</tt> file by running:
<pre>grubby --update-kernel=ALL</pre>
      </td>
      <td xml:lang="en-US">
        Having a non-default grub superuser username makes password-guessing attacks less effective.

For more information on how to configure the grub2 superuser account and password,
please refer to
<ul>
<li>
    <a xmlns='http://www.w3.org/1999/xhtml' href='https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/system_administrators_guide/ch-working_with_the_grub_2_boot_loader#sec-Protecting_GRUB_2_with_a_Password'>https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/system_administrators_guide/ch-working_with_the_grub_2_boot_loader#sec-Protecting_GRUB_2_with_a_Password</a></li>.
</ul>
      </td>
    </tr>
    <tr>
      <td>FIA_UAU.5<br/>FTP_ITC_EXT.1<br/>FCS_SSH_EXT.1<br/>FCS_SSHS_EXT.1</td>
      <td>Install the OpenSSH Server Package</td>
      <td xml:lang="en-US">
        The <tt>openssh-server</tt> package should be installed.
The <code>openssh-server</code> package can be installed with the following command:
<pre>
$ sudo yum install openssh-server</pre>
      </td>
      <td xml:lang="en-US">
        Without protection of the transmitted information, confidentiality, and
integrity may be compromised because unprotected communications can be
intercepted and either read or altered.
      </td>
    </tr>
    <tr>
      <td>FIA_UAU.5<br/>FTP_ITC_EXT.1<br/>FCS_SSH_EXT.1<br/>FCS_SSHC_EXT.1</td>
      <td>Install OpenSSH client software</td>
      <td xml:lang="en-US">
        The <code>openssh-clients</code> package can be installed with the following command:
<pre>
$ sudo yum install openssh-clients</pre>
      </td>
      <td xml:lang="en-US">
        This package includes utilities to make encrypted connections and transfer
files securely to SSH servers.
      </td>
    </tr>
    <tr>
      <td>FIA_X509_EXT.1<br/>FIA_X509_EXT.2</td>
      <td>Ensure gnutls-utils is installed</td>
      <td xml:lang="en-US">
        The <code>gnutls-utils</code> package can be installed with the following command:
<pre>
$ sudo yum install gnutls-utils</pre>
      </td>
      <td xml:lang="en-US">
        GnuTLS is a secure communications library implementing the SSL, TLS and DTLS
protocols and technologies around them. It provides a simple C language
application programming interface (API) to access the secure communications
protocols as well as APIs to parse and write X.509, PKCS #12, OpenPGP and
other required structures.
This package contains command line TLS client and server and certificate
manipulation tools.
      </td>
    </tr>
    <tr>
      <td>FMT_MOD_EXT.1</td>
      <td>Disable User Administration in GNOME3</td>
      <td xml:lang="en-US">
        By default, <tt>GNOME</tt> will allow all users to have some administratrion
capability. This should be disabled so that non-administrative users are not making
configuration changes. To configure the system to disable user administration
capability in the Graphical User Interface (GUI), add or set
<tt>user-administration-disabled</tt> to <tt>true</tt> in
<tt>/etc/dconf/db/local.d/00-security-settings</tt>. For example:
<pre>[org/gnome/desktop/lockdown]
user-administration-disabled=true
</pre>
Once the settings have been added, add a lock to
<tt>/etc/dconf/db/local.d/locks/00-security-settings-lock</tt> to prevent user modification.
For example:
<pre>/org/gnome/desktop/lockdown/user-administration-disabled</pre>
After the settings have been set, run <tt>dconf update</tt>.
      </td>
      <td xml:lang="en-US">
        Allowing all users to have some administratrive capabilities to the system through
the Graphical User Interface (GUI) when they would not have them otherwise could allow
unintended configuration changes as well as a nefarious user the capability to make system
changes such as adding new accounts, etc.
      </td>
    </tr>
    <tr>
      <td>FMT_MOF_EXT.1</td>
      <td>Disable Full User Name on Splash Shield</td>
      <td xml:lang="en-US">
        By default when the screen is locked, the splash shield will show the user's
full name. This should be disabled to prevent casual observers from seeing
who has access to the system. This can be disabled by adding or setting
<tt>show-full-name-in-top-bar</tt> to <tt>false</tt> in
<tt>/etc/dconf/db/local.d/00-security-settings</tt>. For example:
<pre>[org/gnome/desktop/screensaver]
show-full-name-in-top-bar=false
</pre>
Once the settings have been added, add a lock to
<tt>/etc/dconf/db/local.d/locks/00-security-settings-lock</tt> to prevent user modification.
For example:
<pre>/org/gnome/desktop/screensaver/show-full-name-in-top-bar</pre>
After the settings have been set, run <tt>dconf update</tt>.
      </td>
      <td xml:lang="en-US">
        Setting the splash screen to not reveal the logged in user's name
conceals who has access to the system from passersby.
      </td>
    </tr>
    <tr>
      <td>FMT_MOF_EXT.1</td>
      <td>Implement Blank Screensaver</td>
      <td xml:lang="en-US">
        


To set the screensaver mode in the GNOME3 desktop to a blank screen,
add or set <tt>picture-uri</tt> to <tt>string ''</tt> in
<tt>/etc/dconf/db/local.d/00-security-settings</tt>. For example:
<pre>[org/gnome/desktop/screensaver]
picture-uri=string ''
</pre>
Once the settings have been added, add a lock to
<tt>/etc/dconf/db/local.d/locks/00-security-settings-lock</tt> to prevent user modification.
For example:
<pre>/org/gnome/desktop/screensaver/picture-uri</pre>
After the settings have been set, run <tt>dconf update</tt>.
      </td>
      <td xml:lang="en-US">
        Setting the screensaver mode to blank-only conceals the
contents of the display from passersby.
      </td>
    </tr>
    <tr>
      <td>FMT_MOF_EXT.1</td>
      <td>Enable GNOME3 Login Warning Banner</td>
      <td xml:lang="en-US">
        In the default graphical environment, displaying a login warning banner
in the GNOME Display Manager's login screen can be enabled on the login
screen by setting <tt>banner-message-enable</tt> to <tt>true</tt>.
<br /><br />
To enable, add or edit <tt>banner-message-enable</tt> to
<tt>/etc/dconf/db/gdm.d/00-security-settings</tt>. For example:
<pre>[org/gnome/login-screen]
banner-message-enable=true</pre>
Once the setting has been added, add a lock to
<tt>/etc/dconf/db/gdm.d/locks/00-security-settings-lock</tt> to prevent user modification.
For example:
<pre>/org/gnome/login-screen/banner-message-enable</pre>
After the settings have been set, run <tt>dconf update</tt>.
The banner text must also be set.
      </td>
      <td xml:lang="en-US">
        Display of a standardized and approved use notification before granting access to the operating system
ensures privacy and security notification verbiage used is consistent with applicable federal laws,
Executive Orders, directives, policies, regulations, standards, and guidance.
<br /><br />
For U.S. Government systems, system use notifications are required only for access via login interfaces
with human users and are not required when such human interfaces do not exist.
      </td>
    </tr>
    <tr>
      <td>FMT_MOF_EXT.1</td>
      <td>Ensure Users Cannot Change GNOME3 Screensaver Settings</td>
      <td xml:lang="en-US">
        If not already configured, ensure that users cannot change GNOME3 screensaver lock settings
by adding <tt>/org/gnome/desktop/screensaver/lock-delay</tt>
to <tt>/etc/dconf/db/local.d/locks/00-security-settings-lock</tt> to prevent user modification.
For example:
<pre>/org/gnome/desktop/screensaver/lock-delay</pre>
After the settings have been set, run <tt>dconf update</tt>.
      </td>
      <td xml:lang="en-US">
        A session time-out lock is a temporary action taken when a user stops work and moves away from the immediate
physical vicinity of the information system but does not logout because of the temporary nature of the absence.
Rather than relying on the user to manually lock their operating system session prior to vacating the vicinity,
GNOME desktops can be configured to identify when a user's session has idled and take action to initiate the
session lock. As such, users should not be allowed to change session settings.
      </td>
    </tr>
    <tr>
      <td>FMT_MOF_EXT.1</td>
      <td>Ensure Users Cannot Change GNOME3 Screensaver Idle Activation</td>
      <td xml:lang="en-US">
        If not already configured, ensure that users cannot change GNOME3 screensaver lock settings
by adding <pre>/org/gnome/desktop/screensaver/idle-activation-enabled</pre>
to <tt>/etc/dconf/db/local.d/00-security-settings</tt>.
For example:
<pre>/org/gnome/desktop/screensaver/idle-activation-enabled</pre>
After the settings have been set, run <tt>dconf update</tt>.
      </td>
      <td xml:lang="en-US">
        A session lock is a temporary action taken when a user stops work and moves away from the immediate physical vicinity
of the information system but does not want to logout because of the temporary nature of the absense.
      </td>
    </tr>
    <tr>
      <td>FMT_MOF_EXT.1</td>
      <td>Modify the System Login Banner</td>
      <td xml:lang="en-US">
        
To configure the system login banner edit <tt>/etc/issue</tt>. Replace the
default text with a message compliant with the local site policy or a legal
disclaimer.


The DoD required text is either:
<br /><br />
<tt>You are accessing a U.S. Government (USG) Information System (IS) that
is provided for USG-authorized use only. By using this IS (which includes
any device attached to this IS), you consent to the following conditions:
<br />-The USG routinely intercepts and monitors communications on this IS
for purposes including, but not limited to, penetration testing, COMSEC
monitoring, network operations and defense, personnel misconduct (PM), law
enforcement (LE), and counterintelligence (CI) investigations.
<br />-At any time, the USG may inspect and seize data stored on this IS.
<br />-Communications using, or data stored on, this IS are not private,
are subject to routine monitoring, interception, and search, and may be
disclosed or used for any USG-authorized purpose.
<br />-This IS includes security measures (e.g., authentication and access
controls) to protect USG interests -- not for your personal benefit or
privacy.
<br />-Notwithstanding the above, using this IS does not constitute consent
to PM, LE or CI investigative searching or monitoring of the content of
privileged communications, or work product, related to personal
representation or services by attorneys, psychotherapists, or clergy, and
their assistants. Such communications and work product are private and
confidential. See User Agreement for details.</tt>
<br /><br />
OR:
<br /><br />
<tt>I've read &amp; consent to terms in IS user agreem't.</tt>
      </td>
      <td xml:lang="en-US">
        Display of a standardized and approved use notification before granting
access to the operating system ensures privacy and security notification
verbiage used is consistent with applicable federal laws, Executive Orders,
directives, policies, regulations, standards, and guidance.
<br /><br />
System use notifications are required only for access via login interfaces
with human users and are not required when such human interfaces do not
exist.
      </td>
    </tr>
    <tr>
      <td>FMT_MOF_EXT.1</td>
      <td>Set Interactive Session Timeout</td>
      <td xml:lang="en-US">
        Setting the <tt>TMOUT</tt> option in <tt>/etc/profile</tt> ensures that
all user sessions will terminate based on inactivity.
The value of TMOUT should be exported and read only.
The <tt>TMOUT</tt>

setting in a file loaded by <tt>/etc/profile</tt>or <tt>/etc/bashrc</tt>, e.g.
<tt>/etc/profile.d/tmout.sh</tt> should read as follows:
<pre>typeset -xr TMOUT=<abbr title="$var_accounts_tmout"><tt>600</tt></abbr></pre>
or
<pre>declare -xr TMOUT=<abbr title="$var_accounts_tmout"><tt>600</tt></abbr></pre>
Using the <code>typeset</code> keyword is preferred for wider compatibility with ksh and other shells.
      </td>
      <td xml:lang="en-US">
        Terminating an idle session within a short time period reduces
the window of opportunity for unauthorized personnel to take control of a
management session enabled on the console or console port that has been
left unattended.
      </td>
    </tr>
    <tr>
      <td>FMT_MOF_EXT.1</td>
      <td>Set the GNOME3 Login Warning Banner Text</td>
      <td xml:lang="en-US">
        In the default graphical environment, configuring the login warning banner text
in the GNOME Display Manager's login screen can be configured on the login
screen by setting <tt>banner-message-text</tt> to <tt>'<i>APPROVED_BANNER</i>'</tt>
where <i>APPROVED_BANNER</i> is the approved banner for your environment.
<br /><br />
To enable, add or edit <tt>banner-message-text</tt> to

<tt>/etc/dconf/db/gdm.d/00-security-settings</tt>. For example:
<pre>[org/gnome/login-screen]
banner-message-text='<i>APPROVED_BANNER</i>'</pre>
Once the setting has been added, add a lock to
<tt>/etc/dconf/db/gdm.d/locks/00-security-settings-lock</tt> to prevent user modification.
For example:
<pre>/org/gnome/login-screen/banner-message-text</pre>

After the settings have been set, run <tt>dconf update</tt>.
When entering a warning banner that spans several lines, remember
to begin and end the string with <tt>'</tt> and use <tt>\n</tt> for new lines.
      </td>
      <td xml:lang="en-US">
        An appropriate warning message reinforces policy awareness during the logon
process and facilitates possible legal action against attackers.
      </td>
    </tr>
    <tr>
      <td>FMT_MOF_EXT.1</td>
      <td>Set GNOME3 Screensaver Inactivity Timeout</td>
      <td xml:lang="en-US">
        The idle time-out value for inactivity in the GNOME3 desktop is configured via the <tt>idle-delay</tt>
setting must be set under an appropriate configuration file(s) in the <tt>/etc/dconf/db/local.d</tt> directory
and locked in <tt>/etc/dconf/db/local.d/locks</tt> directory to prevent user modification.
<br /><br />
For example, to configure the system for a 15 minute delay, add the following to
<tt>/etc/dconf/db/local.d/00-security-settings</tt>:
<pre>[org/gnome/desktop/session]
idle-delay=uint32 900</pre>
      </td>
      <td xml:lang="en-US">
        A session time-out lock is a temporary action taken when a user stops work and moves away from
the immediate physical vicinity of the information system but does not logout because of the
temporary nature of the absence. Rather than relying on the user to manually lock their operating
system session prior to vacating the vicinity, GNOME3 can be configured to identify when
a user's session has idled and take action to initiate a session lock.
      </td>
    </tr>
    <tr>
      <td>FMT_MOF_EXT.1</td>
      <td>Configure the root Account for Failed Password Attempts</td>
      <td xml:lang="en-US">
        This rule configures the system to lock out the <tt>root</tt> account after a number of
incorrect login attempts using <tt>pam_faillock.so</tt>.

pam_faillock.so module requires multiple entries in pam files. These entries must be carefully
defined to work as expected. In order to avoid errors when manually editing these files, it is
recommended to use the appropriate tools, such as <tt>authselect</tt> or <tt>authconfig</tt>,
depending on the OS version.
      </td>
      <td xml:lang="en-US">
        By limiting the number of failed logon attempts, the risk of unauthorized system access via
user password guessing, also known as brute-forcing, is reduced. Limits are imposed by locking
the account.
      </td>
    </tr>
    <tr>
      <td>FMT_MOF_EXT.1</td>
      <td>Enable GNOME3 Screensaver Lock After Idle Period</td>
      <td xml:lang="en-US">
        
To activate locking of the screensaver in the GNOME3 desktop when it is activated,
add or set <tt>lock-enabled</tt> to <tt>true</tt> in
<tt>/etc/dconf/db/local.d/00-security-settings</tt>. For example:
<pre>[org/gnome/desktop/screensaver]
lock-enabled=true
</pre>
Once the settings have been added, add a lock to
<tt>/etc/dconf/db/local.d/locks/00-security-settings-lock</tt> to prevent user modification.
For example:
<pre>/org/gnome/desktop/screensaver/lock-enabled</pre>
After the settings have been set, run <tt>dconf update</tt>.
      </td>
      <td xml:lang="en-US">
        A session lock is a temporary action taken when a user stops work and moves away from the immediate physical vicinity
of the information system but does not want to logout because of the temporary nature of the absense.
      </td>
    </tr>
    <tr>
      <td>FMT_MOF_EXT.1</td>
      <td>Enable GNOME3 Screensaver Idle Activation</td>
      <td xml:lang="en-US">
        To activate the screensaver in the GNOME3 desktop after a period of inactivity,
add or set <tt>idle-activation-enabled</tt> to <tt>true</tt> in
<tt>/etc/dconf/db/local.d/00-security-settings</tt>. For example:
<pre>[org/gnome/desktop/screensaver]
idle-activation-enabled=true</pre>
Once the setting has been added, add a lock to
<tt>/etc/dconf/db/local.d/locks/00-security-settings-lock</tt> to prevent user modification.
For example:
<pre>/org/gnome/desktop/screensaver/idle-activation-enabled</pre>
After the settings have been set, run <tt>dconf update</tt>.
      </td>
      <td xml:lang="en-US">
        A session time-out lock is a temporary action taken when a user stops work and moves away from the immediate
physical vicinity of the information system but does not logout because of the temporary nature of the absence.
Rather than relying on the user to manually lock their operating system session prior to vacating the vicinity,
GNOME desktops can be configured to identify when a user's session has idled and take action to initiate the
session lock.
<br /><br />
Enabling idle activation of the screensaver ensures the screensaver will
be activated after the idle delay.  Applications requiring continuous,
real-time screen display (such as network management products) require the
login session does not have administrator rights and the display station is located in a
controlled-access area.
      </td>
    </tr>
    <tr>
      <td>FMT_MOF_EXT.1</td>
      <td>Ensure Users Cannot Change GNOME3 Session Idle Settings</td>
      <td xml:lang="en-US">
        If not already configured, ensure that users cannot change GNOME3 session idle settings
by adding <tt>/org/gnome/desktop/session/idle-delay</tt>
to <tt>/etc/dconf/db/local.d/locks/00-security-settings-lock</tt> to prevent user modification.
For example:
<pre>/org/gnome/desktop/session/idle-delay</pre>
After the settings have been set, run <tt>dconf update</tt>.
      </td>
      <td xml:lang="en-US">
        A session time-out lock is a temporary action taken when a user stops work and moves away from the immediate
physical vicinity of the information system but does not logout because of the temporary nature of the absence.
Rather than relying on the user to manually lock their operating system session prior to vacating the vicinity,
GNOME desktops can be configured to identify when a user's session has idled and take action to initiate the
session lock. As such, users should not be allowed to change session settings.
      </td>
    </tr>
    <tr>
      <td>FMT_MOF_EXT.1</td>
      <td>Ensure PAM Enforces Password Requirements - Authentication Retry Prompts Permitted Per-Session</td>
      <td xml:lang="en-US">
        To configure the number of retry prompts that are permitted per-session:

Edit the <tt>pam_pwquality.so</tt> statement in

<tt>/etc/pam.d/system-auth</tt> to show


<tt>retry=<abbr title="$var_password_pam_retry"><tt>3</tt></abbr></tt>, or a lower value if site
policy is more restrictive. The DoD requirement is a maximum of 3 prompts
per session.
      </td>
      <td xml:lang="en-US">
        Setting the password retry prompts that are permitted on a per-session basis to a low value
requires some software, such as SSH, to re-connect. This can slow down and
draw additional attention to some types of password-guessing attacks. Note that this
is different from account lockout, which is provided by the pam_faillock module.
      </td>
    </tr>
    <tr>
      <td>FMT_MOF_EXT.1</td>
      <td>Configure the root Account lock for Failed Password Attempts via pam_tally2</td>
      <td xml:lang="en-US">
        This rule configures the system to lock out the <tt>root</tt> account after a number of
incorrect login attempts using <tt>pam_tally2.so</tt>.
      </td>
      <td xml:lang="en-US">
        By limiting the number of failed logon attempts, the risk of unauthorized system access via
user password guessing, also known as brute-forcing, is reduced. Limits are imposed by locking
the account.
      </td>
    </tr>
    <tr>
      <td>FMT_MOF_EXT.1</td>
      <td>Set GNOME3 Screensaver Lock Delay After Activation Period</td>
      <td xml:lang="en-US">
        To activate the locking delay of the screensaver in the GNOME3 desktop when
the screensaver is activated, add or set <tt>lock-delay</tt> to <tt>uint32 <abbr title="$var_screensaver_lock_delay"><tt>0</tt></abbr></tt> in
<tt>/etc/dconf/db/local.d/00-security-settings</tt>. For example:
<pre>[org/gnome/desktop/screensaver]
lock-delay=uint32 <abbr title="$var_screensaver_lock_delay"><tt>0</tt></abbr>
</pre>
After the settings have been set, run <tt>dconf update</tt>.
      </td>
      <td xml:lang="en-US">
        A session lock is a temporary action taken when a user stops work and moves away from the immediate physical vicinity
of the information system but does not want to logout because of the temporary nature of the absense.
      </td>
    </tr>
    <tr>
      <td>FMT_MOF_EXT.1</td>
      <td>Ensure Users Cannot Change GNOME3 Screensaver Lock After Idle Period</td>
      <td xml:lang="en-US">
        If not already configured, ensure that users cannot change GNOME3 screensaver lock settings
by adding <pre>/org/gnome/desktop/screensaver/lock-enabled</pre>
to <tt>/etc/dconf/db/local.d/locks/00-security-settings</tt>.
For example:
<pre>/org/gnome/desktop/screensaver/lock-enabled</pre>
After the settings have been set, run <tt>dconf update</tt>.
      </td>
      <td xml:lang="en-US">
        A session lock is a temporary action taken when a user stops work and moves away from the immediate physical vicinity
of the information system but does not want to logout because of the temporary nature of the absense.
      </td>
    </tr>
    <tr>
      <td>FMT_MOF_EXT.1</td>
      <td>Set Lockout Time for Failed Password Attempts using pam_tally2</td>
      <td xml:lang="en-US">
        This rule configures the system to lock out accounts during a specified time period after a
number of incorrect login attempts using <tt>pam_tally2.so</tt>.
      </td>
      <td xml:lang="en-US">
        By limiting the number of failed logon attempts, the risk of unauthorized system access via
user password guessing, also known as brute-forcing, is reduced. Limits are imposed by locking
the account.
      </td>
    </tr>
    <tr>
      <td>FMT_MOF_EXT.1</td>
      <td>Set Default firewalld Zone for Incoming Packets</td>
      <td xml:lang="en-US">
        To set the default zone to <tt>drop</tt> for
the built-in default zone which processes incoming IPv4 and IPv6 packets,
modify the following line in
<tt>/etc/firewalld/firewalld.conf</tt> to be:
<pre>DefaultZone=drop</pre>
      </td>
      <td xml:lang="en-US">
        In <tt>firewalld</tt> the default zone is applied only after all
the applicable rules in the table are examined for a match. Setting the
default zone to <tt>drop</tt> implements proper design for a firewall, i.e.
any packets which are not explicitly permitted should not be
accepted.
      </td>
    </tr>
    <tr>
      <td>FMT_MOF_EXT.1</td>
      <td>Install the screen Package</td>
      <td xml:lang="en-US">
        To enable console screen locking, install the <tt>screen</tt> package.
The <code>screen</code> package can be installed with the following command:
<pre>
$ sudo yum install screen</pre>
Instruct users to begin new terminal sessions with the following command:
<pre>$ screen</pre>
The console can now be locked with the following key combination:
<pre>ctrl+a x</pre>
      </td>
      <td xml:lang="en-US">
        A session time-out lock is a temporary action taken when a user stops work and moves away from the immediate
physical vicinity of the information system but does not logout because of the temporary nature of the absence.
Rather than relying on the user to manually lock their operation system session prior to vacating the vicinity,
operating systems need to be able to identify when a user's session has idled and take action to initiate the
session lock.
<br /><br />
The <tt>screen</tt> package allows for a session lock to be implemented and configured.
      </td>
    </tr>
    <tr>
      <td>FMT_MOF_EXT.1</td>
      <td>Ensure Software Patches Installed</td>
      <td xml:lang="en-US">
        
If the system is joined to the Red Hat Network, a Red Hat Satellite Server,
or a yum server, run the following command to install updates:
<pre>$ sudo yum update</pre>
If the system is not configured to use one of these sources, updates (in the form of RPM packages)
can be manually downloaded from the Red Hat Network and installed using <tt>rpm</tt>.

<br /><br />
NOTE: U.S. Defense systems are required to be patched within 30 days or sooner as local policy
dictates.
      </td>
      <td xml:lang="en-US">
        Installing software updates is a fundamental mitigation against
the exploitation of publicly-known vulnerabilities. If the most
recent security patches and updates are not installed, unauthorized
users may take advantage of weaknesses in the unpatched software. The
lack of prompt attention to patching could result in a system compromise.
      </td>
    </tr>
    <tr>
      <td>FMT_MOF_EXT.1</td>
      <td>Set the GNOME3 Login Number of Failures</td>
      <td xml:lang="en-US">
        In the default graphical environment, the GNOME3 login
screen and be configured to restart the authentication process after
a configured number of attempts. This can be configured by setting
<tt>allowed-failures</tt> to <tt>3</tt> or less.
<br /><br />
To enable, add or edit <tt>allowed-failures</tt> to
<tt>/etc/dconf/db/gdm.d/00-security-settings</tt>. For example:
<pre>[org/gnome/login-screen]
allowed-failures=3</pre>
Once the setting has been added, add a lock to
<tt>/etc/dconf/db/gdm.d/locks/00-security-settings-lock</tt> to prevent user modification.
For example:
<pre>/org/gnome/login-screen/allowed-failures</pre>
After the settings have been set, run <tt>dconf update</tt>.
      </td>
      <td xml:lang="en-US">
        Setting the password retry prompts that are permitted on a per-session basis to a low value
requires some software, such as SSH, to re-connect. This can slow down and
draw additional attention to some types of password-guessing attacks.
      </td>
    </tr>
    <tr>
      <td>FMT_MOF_EXT.1</td>
      <td>Install sudo Package</td>
      <td xml:lang="en-US">
        The <code>sudo</code> package can be installed with the following command:
<pre>
$ sudo yum install sudo</pre>
      </td>
      <td xml:lang="en-US">
        <tt>sudo</tt> is a program designed to allow a system administrator to give
limited root privileges to users and log root activity. The basic philosophy
is to give as few privileges as possible but still allow system users to
get their work done.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1</td>
      <td>Configure file name of core dumps</td>
      <td xml:lang="en-US">
        To set the runtime status of the <code>kernel.core_uses_pid</code> kernel parameter, run the following command: <pre>$ sudo sysctl -w kernel.core_uses_pid=0</pre>
To make sure that the setting is persistent, add the following line to a file in the directory <tt>/etc/sysctl.d</tt>: <pre>kernel.core_uses_pid = 0</pre>
      </td>
      <td xml:lang="en-US">
        The default coredump filename is <tt>core</tt>. By setting
<tt>core_uses_pid</tt> to <tt>1</tt>, the coredump filename becomes
<tt>core.PID</tt>. If <tt>core_pattern</tt> does not include
<tt>%p</tt> (default does not) and <tt>core_uses_pid</tt> is set, then
<tt>.PID</tt> will be appended to the filename.
When combined with <tt>kernel.core_pattern = ""</tt> configuration, it
is ensured that no core dumps are generated and also no confusing error
messages are printed by a shell.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1<br/>FMT_MOF_EXT.1<br/>FTA_SSL.1</td>
      <td>Configure the tmux Lock Command</td>
      <td xml:lang="en-US">
        To enable console screen locking in <tt>tmux</tt> terminal multiplexer,
the <tt>vlock</tt> command must be configured to be used as a locking
mechanism.
Add the following line to <tt>/etc/tmux.conf</tt>:
<pre>set -g lock-command vlock</pre>.
The console can now be locked with the following key combination:
<pre>ctrl+b :lock-session</pre>
      </td>
      <td xml:lang="en-US">
        The <tt>tmux</tt> package allows for a session lock to be implemented and configured.
However, the session lock is implemented by an external command. The <tt>tmux</tt>
default configuration does not contain an effective session lock.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1</td>
      <td>Disable storing core dump</td>
      <td xml:lang="en-US">
        The <tt>Storage</tt> option in <tt>[Coredump]</tt> sectionof <tt>/etc/systemd/coredump.conf</tt>
can be set to <tt>none</tt> to disable storing core dumps permanently.
      </td>
      <td xml:lang="en-US">
        A core dump includes a memory image taken at the time the operating system
terminates an application. The memory image could contain sensitive data
and is generally useful only for developers or system operators trying to
debug problems. Enabling core dumps on production systems is not recommended,
however there may be overriding operational requirements to enable advanced
debuging. Permitting temporary enablement of core dumps during such situations
should be reviewed through local needs and policy.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1<br/>FMT_MOF_EXT.1<br/>FTA_SSL.1</td>
      <td>Configure tmux to lock session after inactivity</td>
      <td xml:lang="en-US">
        To enable console screen locking in <tt>tmux</tt> terminal multiplexer
after a period of inactivity,
the <tt>lock-after-time</tt> option has to be set to a value greater than 0 and less than
or equal to 900 in <tt>/etc/tmux.conf</tt>.
      </td>
      <td xml:lang="en-US">
        Locking the session after a period of inactivity limits the
potential exposure if the session is left unattended.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1</td>
      <td>Disable Access to Network bpf() Syscall From Unprivileged Processes</td>
      <td xml:lang="en-US">
        To prevent unprivileged processes from using the <code>bpf()</code> syscall
the <code>kernel.unprivileged_bpf_disabled</code> kernel parameter must
be set to <code>1</code> or <code>2</code>.

Writing <code>1</code> to this entry will disable unprivileged calls to <code>bpf()</code>; once
disabled, calling <code>bpf()</code> without <code>CAP_SYS_ADMIN</code> or <code>CAP_BPF</code> will return <code>-EPERM</code>.
Once set to <code>1</code>, this can't be cleared from the running kernel anymore.

To set the runtime status of the <code>kernel.unprivileged_bpf_disabled</code> kernel parameter,
run the following command:
<pre>$ sudo sysctl -w kernel.unprivileged_bpf_disabled=1</pre>

To make sure that the setting is persistent,
add the following line to a file in the directory <tt>/etc/sysctl.d</tt>:
<pre>kernel.unprivileged_bpf_disabled = 1</pre>

Writing <code>2</code> to this entry will also disable unprivileged calls to <code>bpf()</code>,
however, an admin can still change this setting later on, if needed, by
writing <code>0</code> or <code>1</code> to this entry.

To set the runtime status of the <code>kernel.unprivileged_bpf_disabled</code> kernel parameter,
run the following command:
<pre>$ sudo sysctl -w kernel.unprivileged_bpf_disabled=2</pre>

To make sure that the setting is persistent,
add the following line to a file in the directory <tt>/etc/sysctl.d</tt>:
<pre>kernel.unprivileged_bpf_disabled = 2</pre>
      </td>
      <td xml:lang="en-US">
        Loading and accessing the packet filters programs and maps using the bpf()
syscall has the potential of revealing sensitive information about the kernel state.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1</td>
      <td>Install firewalld Package</td>
      <td xml:lang="en-US">
        The <code>firewalld</code> package can be installed with the following command:
<pre>
$ sudo yum install firewalld</pre>
      </td>
      <td xml:lang="en-US">
        "Firewalld" provides an easy and effective way to block/limit remote access to the system via ports, services, and protocols.

Remote access services, such as those providing remote access to network devices and information systems, which lack automated control capabilities, increase risk and make remote user access management difficult at best.

Remote access is access to DoD nonpublic information systems by an authorized user (or an information system) communicating through an external, non-organization-controlled network. Remote access methods include, for example, dial-up, broadband, and wireless.

Red Hat Enterprise Linux 7 functionality (e.g., SSH) must be capable of taking enforcement action if the audit reveals unauthorized activity.
Automated control of remote access sessions allows organizations to ensure ongoing compliance with remote access policies by enforcing connection rules of remote access applications on a variety of information system components (e.g., servers, workstations, notebook computers, smartphones, and tablets)."
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1</td>
      <td>Disable CAN Support</td>
      <td xml:lang="en-US">
        The Controller Area Network (CAN) is a serial communications
protocol which was initially developed for automotive and
is now also used in marine, industrial, and medical applications.

To configure the system to prevent the <code>can</code>
kernel module from being loaded, add the following line to the file <code>/etc/modprobe.d/can.conf</code>:
<pre>install can /bin/true</pre>

To configure the system to prevent the <code>can</code> from being used,
add the following line to file <code>/etc/modprobe.d/can.conf</code>:
<pre>blacklist can</pre>
      </td>
      <td xml:lang="en-US">
        Disabling CAN protects the system against exploitation of any
flaws in its implementation.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1</td>
      <td>Generate USBGuard Policy</td>
      <td xml:lang="en-US">
        By default USBGuard when enabled prevents access to all USB devices and this lead
to inaccessible system if they use USB mouse/keyboard. To prevent this scenario,
the initial policy configuration must be generated based on current connected USB
devices.
      </td>
      <td xml:lang="en-US">
        The <tt>usbguard</tt> must be configured to allow connected USB devices to work
properly, avoiding the system to become inaccessible.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1</td>
      <td>The Chrony package is installed</td>
      <td xml:lang="en-US">
        System time should be synchronized between all systems in an environment. This is
typically done by establishing an authoritative time server or set of servers and having all
systems synchronize their clocks to them.
The <code>chrony</code> package can be installed with the following command:
<pre>
$ sudo yum install chrony</pre>
      </td>
      <td xml:lang="en-US">
        Time synchronization is important to support time sensitive security mechanisms like
Kerberos and also ensures log files have consistent time records across the enterprise,
which aids in forensic investigations.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1</td>
      <td>Enable dnf-automatic Timer</td>
      <td xml:lang="en-US">
        
The <code>dnf-automatic</code> timer can be enabled with the following command:
<pre>$ sudo systemctl enable dnf-automatic.timer</pre>
      </td>
      <td xml:lang="en-US">
        The <tt>dnf-automatic</tt> is an alternative command line interface (CLI) to <tt>dnf upgrade</tt> with specific facilities to make it suitable to be executed automatically and regularly from systemd timers, cron jobs and similar.
The tool is controlled by <tt>dnf-automatic.timer</tt> SystemD timer.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1</td>
      <td>Authorize USB hubs in USBGuard daemon</td>
      <td xml:lang="en-US">
        To allow authorization of USB hub devices by USBGuard daemon,
add line
<tt>allow with-interface match-all { 09:00:* }</tt>
to <tt>/etc/usbguard/rules.conf</tt>.
      </td>
      <td xml:lang="en-US">
        Without allowing hubs, it might not be possible to use any
USB devices on the system.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1</td>
      <td>Disallow kernel profiling by unprivileged users</td>
      <td xml:lang="en-US">
        To set the runtime status of the <code>kernel.perf_event_paranoid</code> kernel parameter, run the following command: <pre>$ sudo sysctl -w kernel.perf_event_paranoid=2</pre>
To make sure that the setting is persistent, add the following line to a file in the directory <tt>/etc/sysctl.d</tt>: <pre>kernel.perf_event_paranoid = 2</pre>
      </td>
      <td xml:lang="en-US">
        Kernel profiling can reveal sensitive information about kernel behaviour.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1</td>
      <td>Authorize Human Interface Devices in USBGuard daemon</td>
      <td xml:lang="en-US">
        To allow authorization of Human Interface Devices (keyboard, mouse)
by USBGuard daemon,
add the line
<tt>allow with-interface match-all { 03:*:* }</tt>
to <tt>/etc/usbguard/rules.conf</tt>.
      </td>
      <td xml:lang="en-US">
        Without allowing Human Interface Devices, it might not be possible
to interact with the system.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1</td>
      <td>Authorize Human Interface Devices and USB hubs in USBGuard daemon</td>
      <td xml:lang="en-US">
        To allow authorization of USB devices combining human interface device and hub capabilities
by USBGuard daemon,
add the line
<tt>allow with-interface match-all { 03:*:* 09:00:* }</tt>
to <tt>/etc/usbguard/rules.conf</tt>.
      </td>
      <td xml:lang="en-US">
        Without allowing Human Interface Devices, it might not be possible
to interact with the system. Without allowing hubs, it might not be possible to use any
USB devices on the system.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1</td>
      <td>Enable the File Access Policy Service</td>
      <td xml:lang="en-US">
        The File Access Policy service should be enabled.

The <code>fapolicyd</code> service can be enabled with the following command:
<pre>$ sudo systemctl enable fapolicyd.service</pre>
      </td>
      <td xml:lang="en-US">
        The <tt>fapolicyd</tt> service (File Access Policy Daemon)
implements application whitelisting to decide file access rights.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1</td>
      <td>Enable the USBGuard Service</td>
      <td xml:lang="en-US">
        The USBGuard service should be enabled.

The <code>usbguard</code> service can be enabled with the following command:
<pre>$ sudo systemctl enable usbguard.service</pre>
      </td>
      <td xml:lang="en-US">
        The <tt>usbguard</tt> service must be running in order to
enforce the USB device authorization policy for all USB devices.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1</td>
      <td>Install audispd-plugins Package</td>
      <td xml:lang="en-US">
        The <code>audispd-plugins</code> package can be installed with the following command:
<pre>
$ sudo yum install audispd-plugins</pre>
      </td>
      <td xml:lang="en-US">
        <tt>audispd-plugins</tt> provides plugins for the real-time interface to the
audit subsystem, <tt>audispd</tt>. These plugins can do things like relay events
to remote machines or analyze events for suspicious behavior.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1</td>
      <td>Disable TIPC Support</td>
      <td xml:lang="en-US">
        The Transparent Inter-Process Communication (TIPC) protocol
is designed to provide communications between nodes in a
cluster.

To configure the system to prevent the <code>tipc</code>
kernel module from being loaded, add the following line to the file <code>/etc/modprobe.d/tipc.conf</code>:
<pre>install tipc /bin/true</pre>

To configure the system to prevent the <code>tipc</code> from being used,
add the following line to file <code>/etc/modprobe.d/tipc.conf</code>:
<pre>blacklist tipc</pre>
      </td>
      <td xml:lang="en-US">
        Disabling TIPC protects
the system against exploitation of any flaws in its implementation.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1</td>
      <td>Disable IEEE 1394 (FireWire) Support</td>
      <td xml:lang="en-US">
        The IEEE 1394 (FireWire) is a serial bus standard for
high-speed real-time communication.

To configure the system to prevent the <code>firewire-core</code>
kernel module from being loaded, add the following line to the file <code>/etc/modprobe.d/firewire-core.conf</code>:
<pre>install firewire-core /bin/true</pre>

To configure the system to prevent the <code>firewire-core</code> from being used,
add the following line to file <code>/etc/modprobe.d/firewire-core.conf</code>:
<pre>blacklist firewire-core</pre>
      </td>
      <td xml:lang="en-US">
        Disabling FireWire protects the system against exploitation of any
flaws in its implementation.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1</td>
      <td>Ensure /var/log/audit Located On Separate Partition</td>
      <td xml:lang="en-US">
        Audit logs are stored in the <tt>/var/log/audit</tt> directory.

Ensure that <code>/var/log/audit</code> has its own partition or logical
volume at installation time, or migrate it using LVM.
Make absolutely certain that it is large enough to store all
audit logs that will be created by the auditing daemon.
      </td>
      <td xml:lang="en-US">
        Placing <tt>/var/log/audit</tt> in its own partition
enables better separation between audit files
and other files, and helps ensure that
auditing cannot be halted due to the partition running out
of space.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1</td>
      <td>Ensure PAM Enforces Password Requirements - Minimum Length</td>
      <td xml:lang="en-US">
        The pam_pwquality module's <tt>minlen</tt> parameter controls requirements for
minimum characters required in a password. Add <tt>minlen=<abbr title="$var_password_pam_minlen"><tt>15</tt></abbr></tt>
after pam_pwquality to set minimum password length requirements.
      </td>
      <td xml:lang="en-US">
        The shorter the password, the lower the number of possible combinations
that need to be tested before the password is compromised.
<br />
Password complexity, or strength, is a measure of the effectiveness of a
password in resisting attempts at guessing and brute-force attacks.
Password length is one factor of several that helps to determine strength
and how long it takes to crack a password. Use of more characters in a password
helps to exponentially increase the time and/or resources required to
compromise the password.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1</td>
      <td>Disable storing core dumps</td>
      <td xml:lang="en-US">
        To set the runtime status of the <code>kernel.core_pattern</code> kernel parameter, run the following command: <pre>$ sudo sysctl -w kernel.core_pattern=|/bin/false</pre>
To make sure that the setting is persistent, add the following line to a file in the directory <tt>/etc/sysctl.d</tt>: <pre>kernel.core_pattern = |/bin/false</pre>
      </td>
      <td xml:lang="en-US">
        A core dump includes a memory image taken at the time the operating system
terminates an application. The memory image could contain sensitive data and is generally useful
only for developers trying to debug problems.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1</td>
      <td>Ensure PAM Enforces Password Requirements - Minimum Lowercase Characters</td>
      <td xml:lang="en-US">
        The pam_pwquality module's <tt>lcredit</tt> parameter controls requirements for
usage of lowercase letters in a password. When set to a negative number, any password will be required to
contain that many lowercase characters. When set to a positive number, pam_pwquality will grant +1 additional
length credit for each lowercase character. Modify the <tt>lcredit</tt> setting in
<tt>/etc/security/pwquality.conf</tt> to require the use of a lowercase character in passwords.
      </td>
      <td xml:lang="en-US">
        Use of a complex password helps to increase the time and resources required
to compromise the password. Password complexity, or strength, is a measure of
the effectiveness of a password in resisting attempts at guessing and brute-force
attacks.
<br />
Password complexity is one factor of several that determines how long it takes
to crack a password. The more complex the password, the greater the number of
possble combinations that need to be tested before the password is compromised.
Requiring a minimum number of lowercase characters makes password guessing attacks
more difficult by ensuring a larger search space.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1</td>
      <td>Harden the operation of the BPF just-in-time compiler</td>
      <td xml:lang="en-US">
        To set the runtime status of the <code>net.core.bpf_jit_harden</code> kernel parameter, run the following command: <pre>$ sudo sysctl -w net.core.bpf_jit_harden=2</pre>
To make sure that the setting is persistent, add the following line to a file in the directory <tt>/etc/sysctl.d</tt>: <pre>net.core.bpf_jit_harden = 2</pre>
      </td>
      <td xml:lang="en-US">
        When hardened, the extended Berkeley Packet Filter just-in-time compiler
will randomize any kernel addresses in the BPF programs and maps,
and will not expose the JIT addresses in <tt>/proc/kallsyms</tt>.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1</td>
      <td>Disable network management of chrony daemon</td>
      <td xml:lang="en-US">
        The <tt>cmdport</tt> option in <tt>/etc/chrony.conf</tt> can be set to
<tt>0</tt> to stop chrony daemon from listening on the UDP port 323
for management connections made by chronyc.
      </td>
      <td xml:lang="en-US">
        Minimizing the exposure of the server functionality of the chrony
daemon diminishes the attack surface.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1</td>
      <td>Configure dnf-automatic to Install Available Updates Automatically</td>
      <td xml:lang="en-US">
        To ensure that the packages comprising the available updates will be automatically installed by <tt>dnf-automatic</tt>, set <tt>apply_updates</tt> to <tt>yes</tt> under <tt>[commands]</tt> section in <tt>/etc/dnf/automatic.conf</tt>.
      </td>
      <td xml:lang="en-US">
        Installing software updates is a fundamental mitigation against
the exploitation of publicly-known vulnerabilities. If the most
recent security patches and updates are not installed, unauthorized
users may take advantage of weaknesses in the unpatched software. The
lack of prompt attention to patching could result in a system compromise.
The automated installation of updates ensures that recent security patches
are applied in a timely manner.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1</td>
      <td>Disable chrony daemon from acting as server</td>
      <td xml:lang="en-US">
        The <tt>port</tt> option in <tt>/etc/chrony.conf</tt> can be set to
<tt>0</tt> to make chrony daemon to never open any listening port
for server operation and to operate strictly in a client-only mode.
      </td>
      <td xml:lang="en-US">
        In order to prevent unauthorized connection of devices, unauthorized transfer of information, or unauthorized tunneling (i.e., embedding of data types within data types), organizations must disable or restrict unused or unnecessary physical and logical ports/protocols on information systems.
Operating systems are capable of providing a wide variety of functions and services. Some of the functions and services provided by default may not be necessary to support essential organizational operations. Additionally, it is sometimes convenient to provide multiple services from a single component (e.g., VPN and IPS); however, doing so increases risk over limiting the services provided by any one component.
To support the requirements and principles of least functionality, the operating system must support the organizational requirements, providing only essential capabilities and limiting the use of ports, protocols, and/or services to only those required, authorized, and approved to conduct official business or to address authorized quality of life issues.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1</td>
      <td>Ensure nss-tools is installed</td>
      <td xml:lang="en-US">
        The <code>nss-tools</code> package can be installed with the following command:
<pre>
$ sudo yum install nss-tools</pre>
      </td>
      <td xml:lang="en-US">
        Network Security Services (NSS) is a set of libraries designed to
support cross-platform development of security-enabled client and
server applications. Install the <tt>nss-tools</tt> package
to install command-line tools to manipulate the NSS certificate
and key database.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1<br/>FMT_MOF_EXT.1<br/>FTA_SSL.1</td>
      <td>Support session locking with tmux</td>
      <td xml:lang="en-US">
        The <tt>tmux</tt> terminal multiplexer is used to implement
automatic session locking. It should be started from
<tt>/etc/bashrc</tt> or drop-in files within <tt>/etc/profile.d/</tt>.
      </td>
      <td xml:lang="en-US">
        Unlike <tt>bash</tt> itself, the <tt>tmux</tt> terminal multiplexer
provides a mechanism to lock sessions after period of inactivity.
A session lock is a temporary action taken when a user stops work and moves away from the
immediate physical vicinity of the information system but does not want to
log out because of the temporary nature of the absence.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1</td>
      <td>Ensure PAM Enforces Password Requirements - Minimum Special Characters</td>
      <td xml:lang="en-US">
        The pam_pwquality module's <tt>ocredit=</tt> parameter controls requirements for
usage of special (or "other") characters in a password. When set to a negative number,
any password will be required to contain that many special characters.
When set to a positive number, pam_pwquality will grant +1
additional length credit for each special character. Modify the <tt>ocredit</tt> setting
in <tt>/etc/security/pwquality.conf</tt> to equal <abbr title="$var_password_pam_ocredit"><tt>-1</tt></abbr>
to require use of a special character in passwords.
      </td>
      <td xml:lang="en-US">
        Use of a complex password helps to increase the time and resources required
to compromise the password. Password complexity, or strength, is a measure of
the effectiveness of a password in resisting attempts at guessing and brute-force
attacks.
<br /><br />
Password complexity is one factor of several that determines how long it takes
to crack a password. The more complex the password, the greater the number of
possible combinations that need to be tested before the password is compromised.
Requiring a minimum number of special characters makes password guessing attacks
more difficult by ensuring a larger search space.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1</td>
      <td>Disable Access to Network bpf() Syscall From Unprivileged Processes</td>
      <td xml:lang="en-US">
        To set the runtime status of the <code>kernel.unprivileged_bpf_disabled</code> kernel parameter, run the following command: <pre>$ sudo sysctl -w kernel.unprivileged_bpf_disabled=1</pre>
To make sure that the setting is persistent, add the following line to a file in the directory <tt>/etc/sysctl.d</tt>: <pre>kernel.unprivileged_bpf_disabled = 1</pre>
      </td>
      <td xml:lang="en-US">
        Loading and accessing the packet filters programs and maps using the bpf()
syscall has the potential of revealing sensitive information about the kernel state.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1</td>
      <td>Configure SSSD to run as user sssd</td>
      <td xml:lang="en-US">
        SSSD processes should be configured to run as user sssd, not root.
      </td>
      <td xml:lang="en-US">
        To minimize privileges of SSSD processes, they are configured to
run as non-root user.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1</td>
      <td>Ensure PAM Enforces Password Requirements - Minimum Digit Characters</td>
      <td xml:lang="en-US">
        The pam_pwquality module's <tt>dcredit</tt> parameter controls requirements for
usage of digits in a password. When set to a negative number, any password will be required to
contain that many digits. When set to a positive number, pam_pwquality will grant +1 additional
length credit for each digit. Modify the <tt>dcredit</tt> setting in
<tt>/etc/security/pwquality.conf</tt> to require the use of a digit in passwords.
      </td>
      <td xml:lang="en-US">
        Use of a complex password helps to increase the time and resources required
to compromise the password. Password complexity, or strength, is a measure of
the effectiveness of a password in resisting attempts at guessing and brute-force
attacks.
<br /><br />
Password complexity is one factor of several that determines how long it takes
to crack a password. The more complex the password, the greater the number of
possible combinations that need to be tested before the password is compromised.
Requiring digits makes password guessing attacks more difficult by ensuring a larger
search space.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1</td>
      <td>Verify firewalld Enabled</td>
      <td xml:lang="en-US">
        
The <code>firewalld</code> service can be enabled with the following command:
<pre>$ sudo systemctl enable firewalld.service</pre>
      </td>
      <td xml:lang="en-US">
        Access control methods provide the ability to enhance system security posture
by restricting services and known good IP addresses and address ranges. This
prevents connections from unknown hosts and protocols.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1</td>
      <td>Configure dnf-automatic to Install Only Security Updates</td>
      <td xml:lang="en-US">
        To configure <tt>dnf-automatic</tt> to install only security updates
automatically, set <tt>upgrade_type</tt> to <tt>security</tt> under
<tt>[commands]</tt> section in <tt>/etc/dnf/automatic.conf</tt>.
      </td>
      <td xml:lang="en-US">
        By default, <tt>dnf-automatic</tt> installs all available updates.
Reducing the amount of updated packages only to updates that were
issued as a part of a security advisory increases the system stability.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1</td>
      <td>Log USBGuard daemon audit events using Linux Audit</td>
      <td xml:lang="en-US">
        To configure USBGuard daemon to log via Linux Audit
(as opposed directly to a file),
<tt>AuditBackend</tt> option in <tt>/etc/usbguard/usbguard-daemon.conf</tt>
needs to be set to <tt>LinuxAudit</tt>.
      </td>
      <td xml:lang="en-US">
        Using the Linux Audit logging allows for centralized trace
of events.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1</td>
      <td>Disable storing core dumps</td>
      <td xml:lang="en-US">
        The <tt>kernel.core_pattern</tt> option specifies the core dumpfile pattern
name. It can be set to an empty string. In this case, the kernel
behaves differently based on another related option. If
<tt>kernel.core_uses_pid</tt> is set to <tt>1</tt>, then a file named as
<tt>.PID</tt> (where <tt>PID</tt> is process ID of the crashed process) is
created in the working directory. If <tt>kernel.core_uses_pid</tt> is set to
<tt>0</tt>, no coredump is saved.
To set the runtime status of the <code>kernel.core_pattern</code> kernel parameter,
run the following command:
<pre>$ sudo sysctl -w kernel.core_pattern=</pre>

To make sure that the setting is persistent,
add the following line to a file in the directory <tt>/etc/sysctl.d</tt>:
<pre>kernel.core_pattern = </pre>
      </td>
      <td xml:lang="en-US">
        A core dump includes a memory image taken at the time the operating system
terminates an application. The memory image could contain sensitive data and is generally useful
only for developers trying to debug problems.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1</td>
      <td>Disable core dump backtraces</td>
      <td xml:lang="en-US">
        The <tt>ProcessSizeMax</tt> option in <tt>[Coredump]</tt> section
of <tt>/etc/systemd/coredump.conf</tt>
specifies the maximum size in bytes of a core which will be processed.
Core dumps exceeding this size may be stored, but the backtrace will not
be generated.
      </td>
      <td xml:lang="en-US">
        A core dump includes a memory image taken at the time the operating system
terminates an application. The memory image could contain sensitive data
and is generally useful only for developers or system operators trying to
debug problems.

Enabling core dumps on production systems is not recommended,
however there may be overriding operational requirements to enable advanced
debuging. Permitting temporary enablement of core dumps during such situations
should be reviewed through local needs and policy.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1</td>
      <td>Ensure PAM Enforces Password Requirements - Minimum Uppercase Characters</td>
      <td xml:lang="en-US">
        The pam_pwquality module's <tt>ucredit=</tt> parameter controls requirements for
usage of uppercase letters in a password. When set to a negative number, any password will be required to
contain that many uppercase characters. When set to a positive number, pam_pwquality will grant +1 additional
length credit for each uppercase character. Modify the <tt>ucredit</tt> setting in
<tt>/etc/security/pwquality.conf</tt> to require the use of an uppercase character in passwords.
      </td>
      <td xml:lang="en-US">
        Use of a complex password helps to increase the time and resources required to compromise the password.
Password complexity, or strength, is a measure of the effectiveness of a password in resisting attempts
at guessing and brute-force attacks.
<br /><br />
Password complexity is one factor of several that determines how long it takes to crack a password. The more
complex the password, the greater the number of possible combinations that need to be tested before
the password is compromised.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1</td>
      <td>Disable ATM Support</td>
      <td xml:lang="en-US">
        The Asynchronous Transfer Mode (ATM) is a protocol operating on
network, data link, and physical layers, based on virtual circuits
and virtual paths.

To configure the system to prevent the <code>atm</code>
kernel module from being loaded, add the following line to the file <code>/etc/modprobe.d/atm.conf</code>:
<pre>install atm /bin/true</pre>

To configure the system to prevent the <code>atm</code> from being used,
add the following line to file <code>/etc/modprobe.d/atm.conf</code>:
<pre>blacklist atm</pre>
      </td>
      <td xml:lang="en-US">
        Disabling ATM protects the system against exploitation of any
flaws in its implementation.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1<br/>FMT_MOF_EXT.1<br/>FTA_SSL.1</td>
      <td>Prevent user from disabling the screen lock</td>
      <td xml:lang="en-US">
        The <tt>tmux</tt> terminal multiplexer is used to implement
automatic session locking. It should not be listed in
<tt>/etc/shells</tt>.
      </td>
      <td xml:lang="en-US">
        Not listing <tt>tmux</tt> among permitted shells
prevents malicious program running as user
from lowering security by disabling the screen lock.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1</td>
      <td>Disable the use of user namespaces</td>
      <td xml:lang="en-US">
        To set the runtime status of the <code>user.max_user_namespaces</code> kernel parameter,
run the following command:
<pre>$ sudo sysctl -w user.max_user_namespaces=0</pre>

To make sure that the setting is persistent,
add the following line to a file in the directory <tt>/etc/sysctl.d</tt>:
<pre>user.max_user_namespaces = 0</pre>
When containers are deployed on the machine, the value should be set
to large non-zero value.
      </td>
      <td xml:lang="en-US">
        It is detrimental for operating systems to provide, or install by default, functionality exceeding requirements or system objectives.
These unnecessary capabilities or services are often overlooked and therefore may remain unsecured.
They increase the risk to the platform by providing additional attack vectors.
User namespaces are used primarily for Linux containers. The value 0
disallows the use of user namespaces.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1</td>
      <td>Disable acquiring, saving, and processing core dumps</td>
      <td xml:lang="en-US">
        The <tt>systemd-coredump.socket</tt> unit is a socket activation of
the <tt>systemd-coredump@.service</tt> which processes core dumps.
By masking the unit, core dump processing is disabled.
      </td>
      <td xml:lang="en-US">
        A core dump includes a memory image taken at the time the operating system
terminates an application. The memory image could contain sensitive data
and is generally useful only for developers trying to debug problems.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1<br/>FMT_MOF_EXT.1<br/>FTA_SSL.1</td>
      <td>Install the tmux Package</td>
      <td xml:lang="en-US">
        To enable console screen locking, install the <tt>tmux</tt> package.
A session lock is a temporary action taken when a user stops work and moves away from the immediate physical vicinity of the information system but does not want to log out because of the temporary nature of the absence.
The session lock is implemented at the point where session activity can be determined.
Rather than be forced to wait for a period of time to expire before the user session can be locked, Red Hat Enterprise Linux 7 needs to provide users with the ability to manually invoke a session lock so users can secure their session if it is necessary to temporarily vacate the immediate physical vicinity.
Instruct users to begin new terminal sessions with the following command:
<pre>$ tmux</pre>
The console can now be locked with the following key combination:
<pre>ctrl+b :lock-session</pre>
      </td>
      <td xml:lang="en-US">
        A session time-out lock is a temporary action taken when a user stops work and moves away from the immediate
physical vicinity of the information system but does not logout because of the temporary nature of the absence.
Rather than relying on the user to manually lock their operation system session prior to vacating the vicinity,
operating systems need to be able to identify when a user's session has idled and take action to initiate the
session lock.
<br /><br />
The <tt>tmux</tt> package allows for a session lock to be implemented and configured.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1.1</td>
      <td>Disable KDump Kernel Crash Analyzer (kdump)</td>
      <td xml:lang="en-US">
        The <tt>kdump</tt> service provides a kernel crash dump analyzer. It uses the <tt>kexec</tt>
system call to boot a secondary kernel ("capture" kernel) following a system
crash, which can load information from the crashed kernel for analysis.

The <code>kdump</code> service can be disabled with the following command:
<pre>$ sudo systemctl mask --now kdump.service</pre>
      </td>
      <td xml:lang="en-US">
        Kernel core dumps may contain the full contents of system memory at the
time of the crash. Kernel core dumps consume a considerable amount of disk
space and may result in denial of service by exhausting the available space
on the target file system partition. Unless the system is used for kernel
development or testing, there is little need to run the kdump service.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1.1</td>
      <td>Enforce usage of pam_wheel for su authentication</td>
      <td xml:lang="en-US">
        To ensure that only users who are members of the <tt>wheel</tt> group can
run commands with altered privileges through the <tt>su</tt> command, make
sure that the following line exists in the file <tt>/etc/pam.d/su</tt>:
<pre>auth required pam_wheel.so use_uid</pre>
      </td>
      <td xml:lang="en-US">
        The <tt>su</tt> program allows to run commands with a substitute user and
group ID. It is commonly used to run commands as the root user. Limiting
access to such command is considered a good security practice.
      </td>
    </tr>
    <tr>
      <td>FMT_SMF_EXT.1.1</td>
      <td>Configure Logind to terminate idle sessions after certain time of inactivity</td>
      <td xml:lang="en-US">
        To configure <tt>logind</tt> service to terminate inactive user sessions
after <abbr title="$var_logind_session_timeout"><tt>300</tt></abbr> seconds, edit the file
<tt>/etc/systemd/logind.conf</tt>. Ensure that there is a section
<pre>[Login]</pre> which contains the configuration
<pre>StopIdleSessionSec=<abbr title="$var_logind_session_timeout"><tt>300</tt></abbr></pre>.
      </td>
      <td xml:lang="en-US">
        Terminating an idle session within a short time period reduces the window of
opportunity for unauthorized personnel to take control of a management
session enabled on the console or console port that has been let unattended.
      </td>
    </tr>
    <tr>
      <td>FPT_ASLR_EXT.1</td>
      <td>Disable vsyscalls</td>
      <td xml:lang="en-US">
        To disable use of virtual syscalls,
add the argument <tt>vsyscall=none</tt> to the default
GRUB 2 command line for the Linux operating system.
To ensure that <tt>vsyscall=none</tt> is added as a kernel command line
argument to newly installed kernels, add <tt>vsyscall=none</tt> to the
default Grub2 command line for Linux operating systems. Modify the line within
<tt>/etc/default/grub</tt> as shown below:
<pre>GRUB_CMDLINE_LINUX="... vsyscall=none ..."</pre>
Run the following command to update command line for already installed kernels:<pre># grubby --update-kernel=ALL --args="vsyscall=none"</pre>
      </td>
      <td xml:lang="en-US">
        Virtual Syscalls provide an opportunity of attack for a user who has control
of the return instruction pointer.
      </td>
    </tr>
    <tr>
      <td>FPT_ASLR_EXT.1</td>
      <td>Disable vsyscalls in zIPL</td>
      <td xml:lang="en-US">
        To disable use of virtual syscalls,
check that all boot entries in <tt>/boot/loader/entries/*.conf</tt> have <tt>vsyscall=none</tt>
included in its options.<br />
To ensure that new kernels and boot entries continue to disable virtual syscalls,
add <tt>vsyscall=none</tt> to <tt>/etc/kernel/cmdline</tt>.
      </td>
      <td xml:lang="en-US">
        Virtual Syscalls provide an opportunity of attack for a user who has control
of the return instruction pointer.
      </td>
    </tr>
    <tr>
      <td>FPT_TUD_EXT.1<br/>FPT_TUD_EXT.2</td>
      <td>Install subscription-manager Package</td>
      <td xml:lang="en-US">
        The <code>subscription-manager</code> package can be installed with the following command:
<pre>
$ sudo yum install subscription-manager</pre>
      </td>
      <td xml:lang="en-US">
        Red Hat Subscription Manager is a local service which tracks installed products
and subscriptions on a local system to help manage subscription assignments.
It communicates with the backend subscription service (the Customer Portal
or an on-premise server such as Subscription Asset Manager) and works with
content management tools such as .
      </td>
    </tr>
    <tr>
      <td>FPT_TUD_EXT.1<br/>FPT_TUD_EXT.2</td>
      <td>Ensure Red Hat GPG Key Installed</td>
      <td xml:lang="en-US">
        To ensure the system can cryptographically verify base software packages
come from Red Hat (and to connect to the Red Hat Network to receive them),
the Red Hat GPG key must properly be installed. To install the Red Hat GPG
key, run:
<pre>$ sudo subscription-manager register</pre>

If the system is not connected to the Internet or an RHN Satellite, then
install the Red Hat GPG key from trusted media such as the Red Hat
installation CD-ROM or DVD. Assuming the disc is mounted in
<tt>/media/cdrom</tt>, use the following command as the root user to import
it into the keyring:
<pre>$ sudo rpm --import /media/cdrom/RPM-GPG-KEY</pre>

Alternatively, the key may be pre-loaded during the RHEL installation. In
such cases, the key can be installed by running the following command:
<pre>sudo rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release</pre>
      </td>
      <td xml:lang="en-US">
        Changes to software components can have significant effects on the overall
security of the operating system. This requirement ensures the software has
not been tampered with and that it has been provided by a trusted vendor.
The Red Hat GPG key is necessary to cryptographically verify packages are
from Red Hat.
      </td>
    </tr>
    <tr>
      <td>FPT_TUD_EXT.1<br/>FPT_TUD_EXT.2</td>
      <td>Ensure gpgcheck Enabled for All yum Package Repositories</td>
      <td xml:lang="en-US">
        To ensure signature checking is not disabled for
any repos, remove any lines from files in <tt>/etc/yum.repos.d</tt> of the form:
<pre>gpgcheck=0</pre>
      </td>
      <td xml:lang="en-US">
        Verifying the authenticity of the software prior to installation validates
the integrity of the patch or upgrade received from a vendor. This ensures
the software has not been tampered with and that it has been provided by a
trusted vendor. Self-signed certificates are disallowed by this
requirement. Certificates used to verify the software must be from an
approved Certificate Authority (CA)."
      </td>
    </tr>
    <tr>
      <td>FPT_TUD_EXT.1<br/>FPT_TUD_EXT.2</td>
      <td>Install dnf-plugin-subscription-manager Package</td>
      <td xml:lang="en-US">
        The <code>dnf-plugin-subscription-manager</code> package can be installed with the following command:
<pre>
$ sudo yum install dnf-plugin-subscription-manager</pre>
      </td>
      <td xml:lang="en-US">
        This package provides plugins to interact with repositories and subscriptions
from the Red Hat entitlement platform; contains subscription-manager and
product-id plugins.
      </td>
    </tr>
    <tr>
      <td>FPT_TUD_EXT.1<br/>FPT_TUD_EXT.2</td>
      <td>Ensure gpgcheck Enabled for Local Packages</td>
      <td xml:lang="en-US">
        <tt>yum</tt> should be configured to verify the signature(s) of local packages
prior to installation. To configure <tt>yum</tt> to verify signatures of local
packages, set the <tt>localpkg_gpgcheck</tt> to <tt>1</tt> in <tt>/etc/yum.conf</tt>.
      </td>
      <td xml:lang="en-US">
        Changes to any software components can have significant effects to the overall security
of the operating system. This requirement ensures the software has not been tampered and
has been provided by a trusted vendor.
<br /><br />
Accordingly, patches, service packs, device drivers, or operating system components must
be signed with a certificate recognized and approved by the organization.
      </td>
    </tr>
    <tr>
      <td>FPT_TUD_EXT.1<br/>FPT_TUD_EXT.2</td>
      <td>Ensure gpgcheck Enabled In Main yum Configuration</td>
      <td xml:lang="en-US">
        The <tt>gpgcheck</tt> option controls whether
RPM packages' signatures are always checked prior to installation.
To configure yum to check package signatures before installing
them, ensure the following line appears in <tt>/etc/yum.conf</tt> in
the <tt>[main]</tt> section:
<pre>gpgcheck=1</pre>
      </td>
      <td xml:lang="en-US">
        Changes to any software components can have significant effects on the
overall security of the operating system. This requirement ensures the
software has not been tampered with and that it has been provided by a
trusted vendor.
<br />
Accordingly, patches, service packs, device drivers, or operating system
components must be signed with a certificate recognized and approved by the
organization.
<br />Verifying the authenticity of the software prior to installation
validates the integrity of the patch or upgrade received from a vendor.
This ensures the software has not been tampered with and that it has been
provided by a trusted vendor. Self-signed certificates are disallowed by
this requirement. Certificates used to verify the software must be from an
approved Certificate Authority (CA).
      </td>
    </tr>
    <tr>
      <td>FPT_TUD_EXT.1<br/>FPT_TUD_EXT.2</td>
      <td>Ensure SUSE GPG Key Installed</td>
      <td xml:lang="en-US">
        To ensure the system can cryptographically verify base software packages
come from SUSE (and to connect to the SUSE to receive them),
the SUSE GPG key must properly be installed. To install the SUSE GPG
key, run:
<pre>$ sudo zypper install suse-build-key</pre>

If the system is not connected to the Internet or an RHN Satellite, then
install the SUSE GPG key from trusted media such as the SUSE
installation CD-ROM or DVD. Assuming the disc is mounted in
<tt>/media/cdrom</tt>, use the following command as the root user to import
it into the keyring:
<pre>$ sudo rpm --import /media/cdrom/content.key</pre> or
<pre>$ sudo rpm --import /media/cdrom/repodata/repomd.xml.key</pre>

Alternatively, the key may be pre-loaded during the SUSE installation. In
such cases, one can use the repository cache files to install the key,
for example by running the following command:
<pre>sudo rpm --import /var/cache/zypp/raw/Basesystem_Module_15_SP2_x86_64:SLE-Module-Basesystem15-SP2-Pool/repodata/repomd.xml.key</pre>
      </td>
      <td xml:lang="en-US">
        Changes to software components can have significant effects on the overall
security of the operating system. This requirement ensures the software has
not been tampered with and that it has been provided by a trusted vendor.
The SUSE GPG key is necessary to cryptographically verify packages are
from SUSE.
      </td>
    </tr>
    <tr>
      <td>FTA_TAB.1</td>
      <td>Enable SSH Warning Banner</td>
      <td xml:lang="en-US">
        To enable the warning banner and ensure it is consistent
across the system, add or correct the following line in


<tt>/etc/ssh/sshd_config</tt>:

<pre>Banner /etc/issue</pre>
Another section contains information on how to create an
appropriate system-wide warning banner.
      </td>
      <td xml:lang="en-US">
        The warning message reinforces policy awareness during the logon process and
facilitates possible legal action against attackers. Alternatively, systems
whose ownership should not be obvious should ensure usage of a banner that does
not provide easy attribution.
      </td>
    </tr>
    <tr>
      <td>FTA_TAB.1</td>
      <td>Enable SSH Warning Banner</td>
      <td xml:lang="en-US">
        To enable the warning banner and ensure it is consistent
across the system, add or correct the following line in

<tt>/etc/ssh/sshd_config</tt>:

<pre>Banner /etc/issue.net</pre>
Another section contains information on how to create an
appropriate system-wide warning banner.
      </td>
      <td xml:lang="en-US">
        The warning message reinforces policy awareness during the logon process and
facilitates possible legal action against attackers. Alternatively, systems
whose ownership should not be obvious should ensure usage of a banner that does
not provide easy attribution.
      </td>
    </tr>
    <tr>
      <td>FTP_ITC_EXT.1<br/>FCS_SSH_EXT.1.2</td>
      <td>Disable Kerberos Authentication</td>
      <td xml:lang="en-US">
        Unless needed, SSH should not permit extraneous or unnecessary
authentication mechanisms like Kerberos.
<br/>
The default SSH configuration disallows authentication validation through Kerberos.
The appropriate configuration is used if no value is set for <tt>KerberosAuthentication</tt>.
<br/>
To explicitly disable Kerberos authentication, add or correct the following line in


<tt>/etc/ssh/sshd_config</tt>:

<pre>KerberosAuthentication no</pre>
      </td>
      <td xml:lang="en-US">
        Kerberos authentication for SSH is often implemented using GSSAPI. If Kerberos
is enabled through SSH, the SSH daemon provides a means of access to the
system's Kerberos implementation.
Configuring these settings for the SSH daemon provides additional assurance that remote logon via SSH will not use unused methods of authentication, even in the event of misconfiguration elsewhere.
      </td>
    </tr>
    <tr>
      <td>FTP_ITC_EXT.1<br/>FCS_SSH_EXT.1.2</td>
      <td>Disable GSSAPI Authentication</td>
      <td xml:lang="en-US">
        Unless needed, SSH should not permit extraneous or unnecessary
authentication mechanisms like GSSAPI.
<br/>
The default SSH configuration disallows authentications based on GSSAPI. The appropriate
configuration is used if no value is set for <tt>GSSAPIAuthentication</tt>.
<br/>
To explicitly disable GSSAPI authentication, add or correct the following line in


<tt>/etc/ssh/sshd_config</tt>:

<pre>GSSAPIAuthentication no</pre>
      </td>
      <td xml:lang="en-US">
        GSSAPI authentication is used to provide additional authentication mechanisms to
applications. Allowing GSSAPI authentication through SSH exposes the system's
GSSAPI to remote hosts, increasing the attack surface of the system.
      </td>
    </tr>
    <tr>
      <td>FTP_ITC_EXT.1</td>
      <td>Disable Kerberos by removing host keytab</td>
      <td xml:lang="en-US">
        Kerberos is not an approved key distribution method for
Common Criteria. To prevent using Kerberos by system daemons,
remove the Kerberos keytab files, especially
<tt>/etc/krb5.keytab</tt>.
      </td>
      <td xml:lang="en-US">
        The key derivation function (KDF) in Kerberos is not FIPS compatible.
      </td>
    </tr>
    <tr>
      <td>FTP_ITC_EXT.1.1</td>
      <td>Ensure rsyslog is Installed</td>
      <td xml:lang="en-US">
        Rsyslog is installed by default. The <code>rsyslog</code> package can be installed with the following command: <pre> $ sudo yum install rsyslog</pre>
      </td>
      <td xml:lang="en-US">
        The rsyslog package provides the rsyslog daemon, which provides
system logging services.
      </td>
    </tr>
    <tr>
      <td>FTP_ITC_EXT.1.1</td>
      <td>Ensure rsyslog-gnutls is installed</td>
      <td xml:lang="en-US">
        TLS protocol support for rsyslog is installed.

The <code>rsyslog-gnutls</code> package can be installed with the following command:
<pre>
$ sudo yum install rsyslog-gnutls</pre>
      </td>
      <td xml:lang="en-US">
        The rsyslog-gnutls package provides Transport Layer Security (TLS) support
for the rsyslog daemon, which enables secure remote logging.
      </td>
    </tr>
    </tbody>
</table>

</body>
</html>